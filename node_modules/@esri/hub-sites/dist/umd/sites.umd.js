/* @preserve
 * @esri/hub-sites - v9.28.0 - Thu Apr 21 2022 15:28:21 GMT+0000 (Coordinated Universal Time)
 * Copyright (c) 2022 Environmental Systems Research Institute, Inc.
 * Apache-2.0
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@esri/hub-common'), require('@esri/hub-initiatives'), require('@esri/hub-teams')) :
    typeof define === 'function' && define.amd ? define(['exports', '@esri/hub-common', '@esri/hub-initiatives', '@esri/hub-teams'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.arcgisHub = global.arcgisHub || {}, global.arcgisHub, global.arcgisHub, global.arcgisHub));
})(this, (function (exports, hubCommon, hubInitiatives, hubTeams) { 'use strict';

    /**
     * This is the list of page model properties
     * that are included in a page's draft
     */
    var PAGE_DRAFT_INCLUDE_LIST = [
        "item.title",
        "item.snippet",
        "data.values.layout"
    ];

    /**
     * This is the list of site model properties
     * that are included in a site's draft
     */
    var SITE_DRAFT_INCLUDE_LIST = [
        "item.title",
        "item.snippet",
        "item.properties.schemaVersion",
        "data.values.layout",
        "data.values.theme",
        "data.values.headerCss",
        "data.values.headerSass",
        "data.values.footerSass",
        "data.values.footerCss",
        "data.values.faviconUrl",
        "data.values.telemetry",
        "data.values.map",
        "data.values.capabilities",
        "data.values.contentViews",
    ];

    var UNPUBLISHED_CHANGES_KW = "state:hasUnpublishedChanges";

    /**
     * Determines whether an item is a site item or not
     * @param item - the item
     */
    function isSite(item) {
        return hubCommon.normalizeItemType(item) === "Hub Site Application";
    }

    /**
     * Remove a Site from the Page's list of sites it is connected to
     * @param {String} siteId Id of the site to unlink from the page
     * @param {Object} pageModel Page Model
     */
    function removeSiteFromPage(siteId, pageModel) {
        // look for the site in the page hash...
        return hubCommon.getWithDefault(pageModel, "data.values.sites", []).filter(function (e) {
            return e.id !== siteId;
        });
    }

    /**
     * Unlink a Page from a Site and vice-versa
     * This is a super tolerant function. It can be passed ids, models or a mix.
     * It will handle either the site or the page items being missing
     * It will handle cases where the current user lacks update privs to either item or rights
     * to change the sharing. Of course in those cases we clearly can't make the changes, and
     * this function will resolve as though they were made, usually the UI tier will have
     * ensured that the current user has write access to at least one of the main entities
     * @param {IUnlinkRequestOptions} unlinkRequestOptions {siteModel || siteId, pageModel || pageId, authorization...}
     */
    function unlinkSiteAndPage(unlinkRequestOptions) {
        var unshareGroups = [];
        var promises = [];
        var pageModel;
        var siteModel;
        var requestOptions = {
            authentication: unlinkRequestOptions.authentication
        };
        // get the models from the options...
        return Promise.all([
            hubCommon.getModelFromOptions("page", unlinkRequestOptions),
            hubCommon.getModelFromOptions("site", unlinkRequestOptions)
        ])
            .then(function (models) {
            pageModel = models[0], siteModel = models[1];
            // Handle the site
            if (!siteModel.isMissing) {
                var pages = hubCommon.getWithDefault(siteModel, "data.values.pages", []);
                // remove the page from the pages array on the model
                siteModel.data.values.pages = hubCommon.withoutByProp("id", pageModel.item.id, pages);
                // collect the groups we'll unshare the page from
                unshareGroups = hubCommon.maybePush(hubCommon.getProp(siteModel, "item.properties.collaborationGroupId"), unshareGroups);
                unshareGroups = hubCommon.maybePush(hubCommon.getProp(siteModel, "item.properties.contentGroupId"), unshareGroups);
                // update the site, but failSafe so we don't have to do any checking if the current user can update it
                promises.push(hubCommon.failSafeUpdate(siteModel, requestOptions));
            }
            // Handle the page
            if (!pageModel.isMissing) {
                var sites = hubCommon.getWithDefault(pageModel, "data.values.sites", []);
                // remove site from sites array on the model
                pageModel.data.values.sites = hubCommon.withoutByProp("id", siteModel.item.id, sites);
                promises.push(hubCommon.failSafeUpdate(pageModel, requestOptions));
                // now about the groups
                var failSafeUnshare = hubCommon.failSafe(hubCommon.unshareItemFromGroups);
                promises.push(failSafeUnshare(pageModel.item.id, unshareGroups, requestOptions));
            }
            return Promise.all(promises);
        })
            .then(function () {
            // return the updated models
            return {
                pageModel: pageModel,
                siteModel: siteModel
            };
        });
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Checks parameters to see if we should use FormData to send the request
     * @param params The object whose keys will be encoded.
     * @return A boolean indicating if FormData will be required.
     */
    function requiresFormData(params) {
        return Object.keys(params).some(function (key) {
            var value = params[key];
            if (!value) {
                return false;
            }
            if (value && value.toParam) {
                value = value.toParam();
            }
            var type = value.constructor.name;
            switch (type) {
                case "Array":
                    return false;
                case "Object":
                    return false;
                case "Date":
                    return false;
                case "Function":
                    return false;
                case "Boolean":
                    return false;
                case "String":
                    return false;
                case "Number":
                    return false;
                default:
                    return true;
            }
        });
    }
    /**
     * Converts parameters to the proper representation to send to the ArcGIS REST API.
     * @param params The object whose keys will be encoded.
     * @return A new object with properly encoded values.
     */
    function processParams(params) {
        var newParams = {};
        Object.keys(params).forEach(function (key) {
            var _a, _b;
            var param = params[key];
            if (param && param.toParam) {
                param = param.toParam();
            }
            if (!param &&
                param !== 0 &&
                typeof param !== "boolean" &&
                typeof param !== "string") {
                return;
            }
            var type = param.constructor.name;
            var value;
            // properly encodes objects, arrays and dates for arcgis.com and other services.
            // ported from https://github.com/Esri/esri-leaflet/blob/master/src/Request.js#L22-L30
            // also see https://github.com/Esri/arcgis-rest-js/issues/18:
            // null, undefined, function are excluded. If you want to send an empty key you need to send an empty string "".
            switch (type) {
                case "Array":
                    // Based on the first element of the array, classify array as an array of arrays, an array of objects
                    // to be stringified, or an array of non-objects to be comma-separated
                    // eslint-disable-next-line no-case-declarations
                    var firstElementType = (_b = (_a = param[0]) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name;
                    value =
                        firstElementType === "Array" ? param : // pass thru array of arrays
                            firstElementType === "Object" ? JSON.stringify(param) : // stringify array of objects
                                param.join(","); // join other types of array elements
                    break;
                case "Object":
                    value = JSON.stringify(param);
                    break;
                case "Date":
                    value = param.valueOf();
                    break;
                case "Function":
                    value = null;
                    break;
                case "Boolean":
                    value = param + "";
                    break;
                default:
                    value = param;
                    break;
            }
            if (value || value === 0 || typeof value === "string" || Array.isArray(value)) {
                newParams[key] = value;
            }
        });
        return newParams;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes keys and parameters for use in a URL's query string.
     *
     * @param key Parameter's key
     * @param value Parameter's value
     * @returns Query string with key and value pairs separated by "&"
     */
    function encodeParam(key, value) {
        // For array of arrays, repeat key=value for each element of containing array
        if (Array.isArray(value) && value[0] && Array.isArray(value[0])) {
            return value.map(function (arrayElem) { return encodeParam(key, arrayElem); }).join("&");
        }
        return encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
    /**
     * Encodes the passed object as a query string.
     *
     * @param params An object to be encoded.
     * @returns An encoded query string.
     */
    function encodeQueryString(params) {
        var newParams = processParams(params);
        return Object.keys(newParams)
            .map(function (key) {
            return encodeParam(key, newParams[key]);
        })
            .join("&");
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes parameters in a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object in browsers or in a [FormData](https://github.com/form-data/form-data) in Node.js
     *
     * @param params An object to be encoded.
     * @returns The complete [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.
     */
    function encodeFormData(params, forceFormData) {
        // see https://github.com/Esri/arcgis-rest-js/issues/499 for more info.
        var useFormData = requiresFormData(params) || forceFormData;
        var newParams = processParams(params);
        if (useFormData) {
            var formData_1 = new FormData();
            Object.keys(newParams).forEach(function (key) {
                if (typeof Blob !== "undefined" && newParams[key] instanceof Blob) {
                    /* To name the Blob:
                     1. look to an alternate request parameter called 'fileName'
                     2. see if 'name' has been tacked onto the Blob manually
                     3. if all else fails, use the request parameter
                    */
                    var filename = newParams["fileName"] || newParams[key].name || key;
                    formData_1.append(key, newParams[key], filename);
                }
                else {
                    formData_1.append(key, newParams[key]);
                }
            });
            return formData_1;
        }
        else {
            return encodeQueryString(params);
        }
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    // TypeScript 2.1 no longer allows you to extend built in types. See https://github.com/Microsoft/TypeScript/issues/12790#issuecomment-265981442
    // and https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
    //
    // This code is from MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types.
    var ArcGISRequestError = /** @class */ (function () {
        /**
         * Create a new `ArcGISRequestError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options and parameters of the request
         */
        function ArcGISRequestError(message, code, response, url, options) {
            message = message || "UNKNOWN_ERROR";
            code = code || "UNKNOWN_ERROR_CODE";
            this.name = "ArcGISRequestError";
            this.message =
                code === "UNKNOWN_ERROR_CODE" ? message : code + ": " + message;
            this.originalMessage = message;
            this.code = code;
            this.response = response;
            this.url = url;
            this.options = options;
        }
        return ArcGISRequestError;
    }());
    ArcGISRequestError.prototype = Object.create(Error.prototype);
    ArcGISRequestError.prototype.constructor = ArcGISRequestError;

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Method used internally to surface messages to developers.
     */
    function warn(message) {
        if (console && console.warn) {
            console.warn.apply(console, [message]);
        }
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    var NODEJS_DEFAULT_REFERER_HEADER = "@esri/arcgis-rest-js";
    var DEFAULT_ARCGIS_REQUEST_OPTIONS = {
        httpMethod: "POST",
        params: {
            f: "json",
        },
    };
    var ArcGISAuthError = /** @class */ (function (_super) {
        __extends(ArcGISAuthError, _super);
        /**
         * Create a new `ArcGISAuthError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options of the request
         */
        function ArcGISAuthError(message, code, response, url, options) {
            if (message === void 0) { message = "AUTHENTICATION_ERROR"; }
            if (code === void 0) { code = "AUTHENTICATION_ERROR_CODE"; }
            var _this = _super.call(this, message, code, response, url, options) || this;
            _this.name = "ArcGISAuthError";
            _this.message =
                code === "AUTHENTICATION_ERROR_CODE" ? message : code + ": " + message;
            return _this;
        }
        ArcGISAuthError.prototype.retry = function (getSession, retryLimit) {
            var _this = this;
            if (retryLimit === void 0) { retryLimit = 3; }
            var tries = 0;
            var retryRequest = function (resolve, reject) {
                getSession(_this.url, _this.options)
                    .then(function (session) {
                    var newOptions = __assign(__assign({}, _this.options), { authentication: session });
                    tries = tries + 1;
                    return request(_this.url, newOptions);
                })
                    .then(function (response) {
                    resolve(response);
                })
                    .catch(function (e) {
                    if (e.name === "ArcGISAuthError" && tries < retryLimit) {
                        retryRequest(resolve, reject);
                    }
                    else if (e.name === "ArcGISAuthError" && tries >= retryLimit) {
                        reject(_this);
                    }
                    else {
                        reject(e);
                    }
                });
            };
            return new Promise(function (resolve, reject) {
                retryRequest(resolve, reject);
            });
        };
        return ArcGISAuthError;
    }(ArcGISRequestError));
    /**
     * Checks for errors in a JSON response from the ArcGIS REST API. If there are no errors, it will return the `data` passed in. If there is an error, it will throw an `ArcGISRequestError` or `ArcGISAuthError`.
     *
     * @param data The response JSON to check for errors.
     * @param url The url of the original request
     * @param params The parameters of the original request
     * @param options The options of the original request
     * @returns The data that was passed in the `data` parameter
     */
    function checkForErrors(response, url, params, options, originalAuthError) {
        // this is an error message from billing.arcgis.com backend
        if (response.code >= 400) {
            var message = response.message, code = response.code;
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        // error from ArcGIS Online or an ArcGIS Portal or server instance.
        if (response.error) {
            var _a = response.error, message = _a.message, code = _a.code, messageCode = _a.messageCode;
            var errorCode = messageCode || code || "UNKNOWN_ERROR_CODE";
            if (code === 498 ||
                code === 499 ||
                messageCode === "GWM_0003" ||
                (code === 400 && message === "Unable to generate token.")) {
                if (originalAuthError) {
                    throw originalAuthError;
                }
                else {
                    throw new ArcGISAuthError(message, errorCode, response, url, options);
                }
            }
            throw new ArcGISRequestError(message, errorCode, response, url, options);
        }
        // error from a status check
        if (response.status === "failed" || response.status === "failure") {
            var message = void 0;
            var code = "UNKNOWN_ERROR_CODE";
            try {
                message = JSON.parse(response.statusMessage).message;
                code = JSON.parse(response.statusMessage).code;
            }
            catch (e) {
                message = response.statusMessage || response.message;
            }
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        return response;
    }
    /**
     * ```js
     * import { request } from '@esri/arcgis-rest-request';
     * //
     * request('https://www.arcgis.com/sharing/rest')
     *   .then(response) // response.currentVersion === 5.2
     * //
     * request('https://www.arcgis.com/sharing/rest', {
     *   httpMethod: "GET"
     * })
     * //
     * request('https://www.arcgis.com/sharing/rest/search', {
     *   params: { q: 'parks' }
     * })
     *   .then(response) // response.total => 78379
     * ```
     * Generic method for making HTTP requests to ArcGIS REST API endpoints.
     *
     * @param url - The URL of the ArcGIS REST API endpoint.
     * @param requestOptions - Options for the request, including parameters relevant to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function request(url, requestOptions) {
        if (requestOptions === void 0) { requestOptions = { params: { f: "json" } }; }
        var options = __assign(__assign(__assign({ httpMethod: "POST" }, DEFAULT_ARCGIS_REQUEST_OPTIONS), requestOptions), {
            params: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.params), requestOptions.params),
            headers: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.headers), requestOptions.headers),
        });
        var missingGlobals = [];
        var recommendedPackages = [];
        // don't check for a global fetch if a custom implementation was passed through
        if (!options.fetch && typeof fetch !== "undefined") {
            options.fetch = fetch.bind(Function("return this")());
        }
        else {
            missingGlobals.push("`fetch`");
            recommendedPackages.push("`node-fetch`");
        }
        if (typeof Promise === "undefined") {
            missingGlobals.push("`Promise`");
            recommendedPackages.push("`es6-promise`");
        }
        if (typeof FormData === "undefined") {
            missingGlobals.push("`FormData`");
            recommendedPackages.push("`isomorphic-form-data`");
        }
        if (!options.fetch ||
            typeof Promise === "undefined" ||
            typeof FormData === "undefined") {
            throw new Error("`arcgis-rest-request` requires a `fetch` implementation and global variables for `Promise` and `FormData` to be present in the global scope. You are missing " + missingGlobals.join(", ") + ". We recommend installing the " + recommendedPackages.join(", ") + " modules at the root of your application to add these to the global scope. See https://bit.ly/2KNwWaJ for more info.");
        }
        var httpMethod = options.httpMethod, authentication = options.authentication, rawResponse = options.rawResponse;
        var params = __assign({ f: "json" }, options.params);
        var originalAuthError = null;
        var fetchOptions = {
            method: httpMethod,
            /* ensures behavior mimics XMLHttpRequest.
            needed to support sending IWA cookies */
            credentials: options.credentials || "same-origin",
        };
        // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header
        // and that request needs to send cookies cross domain
        // so we need to set the credentials to "include"
        if (options.headers &&
            options.headers["X-Esri-Auth-Client-Id"] &&
            url.indexOf("/oauth2/platformSelf") > -1) {
            fetchOptions.credentials = "include";
        }
        return (authentication
            ? authentication.getToken(url, { fetch: options.fetch }).catch(function (err) {
                /**
                 * append original request url and requestOptions
                 * to the error thrown by getToken()
                 * to assist with retrying
                 */
                err.url = url;
                err.options = options;
                /**
                 * if an attempt is made to talk to an unfederated server
                 * first try the request anonymously. if a 'token required'
                 * error is thrown, throw the UNFEDERATED error then.
                 */
                originalAuthError = err;
                return Promise.resolve("");
            })
            : Promise.resolve(""))
            .then(function (token) {
            if (token.length) {
                params.token = token;
            }
            if (authentication && authentication.getDomainCredentials) {
                fetchOptions.credentials = authentication.getDomainCredentials(url);
            }
            // Custom headers to add to request. IRequestOptions.headers with merge over requestHeaders.
            var requestHeaders = {};
            if (fetchOptions.method === "GET") {
                // Prevents token from being passed in query params when hideToken option is used.
                /* istanbul ignore if - window is always defined in a browser. Test case is covered by Jasmine in node test */
                if (params.token &&
                    options.hideToken &&
                    // Sharing API does not support preflight check required by modern browsers https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request
                    typeof window === "undefined") {
                    requestHeaders["X-Esri-Authorization"] = "Bearer " + params.token;
                    delete params.token;
                }
                // encode the parameters into the query string
                var queryParams = encodeQueryString(params);
                // dont append a '?' unless parameters are actually present
                var urlWithQueryString = queryParams === "" ? url : url + "?" + encodeQueryString(params);
                if (
                // This would exceed the maximum length for URLs specified by the consumer and requires POST
                (options.maxUrlLength &&
                    urlWithQueryString.length > options.maxUrlLength) ||
                    // Or if the customer requires the token to be hidden and it has not already been hidden in the header (for browsers)
                    (params.token && options.hideToken)) {
                    // the consumer specified a maximum length for URLs
                    // and this would exceed it, so use post instead
                    fetchOptions.method = "POST";
                    // If the token was already added as a Auth header, add the token back to body with other params instead of header
                    if (token.length && options.hideToken) {
                        params.token = token;
                        // Remove existing header that was added before url query length was checked
                        delete requestHeaders["X-Esri-Authorization"];
                    }
                }
                else {
                    // just use GET
                    url = urlWithQueryString;
                }
            }
            /* updateResources currently requires FormData even when the input parameters dont warrant it.
        https://developers.arcgis.com/rest/users-groups-and-items/update-resources.htm
            see https://github.com/Esri/arcgis-rest-js/pull/500 for more info. */
            var forceFormData = new RegExp("/items/.+/updateResources").test(url);
            if (fetchOptions.method === "POST") {
                fetchOptions.body = encodeFormData(params, forceFormData);
            }
            // Mixin headers from request options
            fetchOptions.headers = __assign(__assign({}, requestHeaders), options.headers);
            /* istanbul ignore next - karma reports coverage on browser tests only */
            if (typeof window === "undefined" && !fetchOptions.headers.referer) {
                fetchOptions.headers.referer = NODEJS_DEFAULT_REFERER_HEADER;
            }
            /* istanbul ignore else blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */
            if (!requiresFormData(params) && !forceFormData) {
                fetchOptions.headers["Content-Type"] =
                    "application/x-www-form-urlencoded";
            }
            return options.fetch(url, fetchOptions);
        })
            .then(function (response) {
            if (!response.ok) {
                // server responded w/ an actual error (404, 500, etc)
                var status_1 = response.status, statusText = response.statusText;
                throw new ArcGISRequestError(statusText, "HTTP " + status_1, response, url, options);
            }
            if (rawResponse) {
                return response;
            }
            switch (params.f) {
                case "json":
                    return response.json();
                case "geojson":
                    return response.json();
                case "html":
                    return response.text();
                case "text":
                    return response.text();
                /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust that isomorphic fetch will do its job */
                default:
                    return response.blob();
            }
        })
            .then(function (data) {
            if ((params.f === "json" || params.f === "geojson") && !rawResponse) {
                var response = checkForErrors(data, url, params, options, originalAuthError);
                if (originalAuthError) {
                    /* If the request was made to an unfederated service that
                    didn't require authentication, add the base url and a dummy token
                    to the list of trusted servers to avoid another federation check
                    in the event of a repeat request */
                    var truncatedUrl = url
                        .toLowerCase()
                        .split(/\/rest(\/admin)?\/services\//)[0];
                    options.authentication.federatedServers[truncatedUrl] = {
                        token: [],
                        // default to 24 hours
                        expires: new Date(Date.now() + 86400 * 1000),
                    };
                    originalAuthError = null;
                }
                return response;
            }
            else {
                return data;
            }
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper for methods with lots of first order request options to pass through as request parameters.
     */
    function appendCustomParams(customOptions, keys, baseOptions) {
        var requestOptionsKeys = [
            "params",
            "httpMethod",
            "rawResponse",
            "authentication",
            "portal",
            "fetch",
            "maxUrlLength",
            "headers"
        ];
        var options = __assign(__assign({ params: {} }, baseOptions), customOptions);
        // merge all keys in customOptions into options.params
        options.params = keys.reduce(function (value, key) {
            if (customOptions[key] || typeof customOptions[key] === "boolean") {
                value[key] = customOptions[key];
            }
            return value;
        }, options.params);
        // now remove all properties in options that don't exist in IRequestOptions
        return requestOptionsKeys.reduce(function (value, key) {
            if (options[key]) {
                value[key] = options[key];
            }
            return value;
        }, {});
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper method to ensure that user supplied urls don't include whitespace or a trailing slash.
     */
    function cleanUrl(url) {
        // Guard so we don't try to trim something that's not a string
        if (typeof url !== "string") {
            return url;
        }
        // trim leading and trailing spaces, but not spaces inside the url
        url = url.trim();
        // remove the trailing slash to the url if one was included
        if (url[url.length - 1] === "/") {
            url = url.slice(0, -1);
        }
        return url;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper that returns the appropriate portal url for a given request. `requestOptions.portal` is given
     * precedence over `authentication.portal`. If neither `portal` nor `authentication` is present,
     * `www.arcgis.com/sharing/rest` is returned.
     *
     * @param requestOptions - Request options that may have authentication manager
     * @returns Portal url to be used in API requests
     */
    function getPortalUrl(requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        // use portal in options if specified
        if (requestOptions.portal) {
            return cleanUrl(requestOptions.portal);
        }
        // if auth was passed, use that portal
        if (requestOptions.authentication) {
            // the portal url is already scrubbed in the auth package
            return requestOptions.authentication.portal;
        }
        // default to arcgis.com
        return "https://www.arcgis.com/sharing/rest";
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Serialize an item and its data into a json format accepted by the Portal API for create and update operations
     *
     * @param item Item to be serialized
     * @returns a formatted json object to be sent to Portal
     */
    function serializeItem(item) {
        // create a clone so we're not messing with the original
        var clone = JSON.parse(JSON.stringify(item));
        // binary data needs POSTed as a `file`
        // JSON object literals should be passed as `text`.
        if (clone.data) {
            (typeof Blob !== "undefined" && item.data instanceof Blob) ||
                // Node.js doesn't implement Blob
                item.data.constructor.name === "ReadStream"
                ? (clone.file = item.data)
                : (clone.text = item.data);
            delete clone.data;
        }
        return clone;
    }
    /**
     * `requestOptions.owner` is given priority, `requestOptions.item.owner` will be checked next. If neither are present, `authentication.getUserName()` will be used instead.
     */
    function determineOwner(requestOptions) {
        if (requestOptions.owner) {
            return Promise.resolve(requestOptions.owner);
        }
        else if (requestOptions.item && requestOptions.item.owner) {
            return Promise.resolve(requestOptions.item.owner);
        }
        else if (requestOptions.authentication &&
            requestOptions.authentication.getUsername) {
            return requestOptions.authentication.getUsername();
        }
        else {
            return Promise.reject(new Error("Could not determine the owner of this item. Pass the `owner`, `item.owner`, or `authentication` option."));
        }
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { updateItem } from "@esri/arcgis-rest-portal";
     * //
     * updateItem({
     *   item: {
     *     id: "3ef",
     *     description: "A three hour tour"
     *   },
     *   authentication
     * })
     *   .then(response)
     * ```
     * Update an Item. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/update-item.htm) for more information.
     *
     * @param requestOptions - Options for the request.
     * @returns A Promise that updates an item.
     */
    function updateItem(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = requestOptions.folderId
                ? getPortalUrl(requestOptions) + "/content/users/" + owner + "/" + requestOptions.folderId + "/items/" + requestOptions.item.id + "/update"
                : getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.item.id + "/update";
            // serialize the item into something Portal will accept
            requestOptions.params = __assign(__assign({}, requestOptions.params), serializeItem(requestOptions.item));
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { addItemResource } from "@esri/arcgis-rest-portal";
     * //
     * // Add a file resource
     * addItemResource({
     *   id: '3ef',
     *   resource: file,
     *   name: 'bigkahuna.jpg',
     *   authentication
     * })
     *   .then(response)
     * //
     * // Add a text resource
     * addItemResource({
     *   id: '4fg',
     *   content: "Text content",
     *   name: 'bigkahuna.txt',
     *   authentication
     * })
     *   .then(response)
     * ```
     * Add a resource associated with an item. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-resources.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise to add item resources.
     */
    function addItemResource(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.id + "/addResources";
            requestOptions.params = __assign({ file: requestOptions.resource, fileName: requestOptions.name, resourcesPrefix: requestOptions.prefix, text: requestOptions.content, access: requestOptions.private ? "private" : "inherit" }, requestOptions.params);
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { createItemInFolder } from "@esri/arcgis-rest-portal";
     * //
     * createItemInFolder({
     *   item: {
     *     title: "The Amazing Voyage",
     *     type: "Web Map"
     *   },
     *   folderId: 'fe8',
     *   authentication
     * })
     * ```
     * Create an item in a folder. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-item.htm) for more information.
     *
     * @param requestOptions = Options for the request
     */
    function createItemInFolder(requestOptions) {
        if (requestOptions.multipart && !requestOptions.filename) {
            return Promise.reject(new Error("The filename is required for a multipart request."));
        }
        return determineOwner(requestOptions).then(function (owner) {
            var baseUrl = getPortalUrl(requestOptions) + "/content/users/" + owner;
            var url = baseUrl + "/addItem";
            if (requestOptions.folderId) {
                url = baseUrl + "/" + requestOptions.folderId + "/addItem";
            }
            requestOptions.params = __assign(__assign({}, requestOptions.params), serializeItem(requestOptions.item));
            // serialize the item into something Portal will accept
            var options = appendCustomParams(requestOptions, [
                "owner",
                "folderId",
                "file",
                "dataUrl",
                "text",
                "async",
                "multipart",
                "filename",
                "overwrite"
            ], {
                params: __assign({}, requestOptions.params)
            });
            return request(url, options);
        });
    }
    /**
     * ```js
     * import { createItem } from "@esri/arcgis-rest-portal";
     * //
     * createItem({
     *   item: {
     *     title: "The Amazing Voyage",
     *     type: "Web Map"
     *   },
     *   authentication
     * })
     * ```
     * Create an Item in the user's root folder. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-item.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that creates an item.
     */
    function createItem(requestOptions) {
        // delegate to createItemInFolder placing in the root of the filestore
        var options = __assign({ folderId: null }, requestOptions);
        return createItemInFolder(options);
    }

    // eslint-disable-next-line no-control-regex
    var CONTROL_CHAR_MATCHER = /[\x00-\x1F\x7F-\x9F\xA0]/g;
    /**
     * Returns a new string with all control characters removed.
     *
     * Doesn't remove characters from input string.
     *
     * @param str - the string to scrub
     */
    function scrubControlChars(str) {
        return str.replace(CONTROL_CHAR_MATCHER, "");
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Get the fully qualified base URL to the REST end point for an item.
     * @param id Item Id
     * @param portalUrlOrRequestOptions a portal URL or request options
     * @returns URL to the item's REST end point, defaults to `https://www.arcgis.com/sharing/rest/content/items/{id}`
     */
    var getItemBaseUrl = function (id, portalUrlOrRequestOptions) {
        var portalUrl = typeof portalUrlOrRequestOptions === "string"
            ? portalUrlOrRequestOptions
            : getPortalUrl(portalUrlOrRequestOptions);
        return portalUrl + "/content/items/" + id;
    };
    /**
     * ```
     * import { getItemData } from "@esri/arcgis-rest-portal";
     * //
     * getItemData("ae7")
     *   .then(response)
     * // or
     * getItemData("ae7", { authentication })
     *   .then(response)
     * ```
     * Get the /data for an item. If no data exists, returns `undefined`. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/item-data.htm) for more information.
     * @param id - Item Id
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the json data for the item.
     */
    function getItemData(id, requestOptions) {
        var url = getItemBaseUrl(id, requestOptions) + "/data";
        // default to a GET request
        var options = __assign({ httpMethod: "GET", params: {} }, requestOptions);
        if (options.file) {
            options.params.f = null;
        }
        return request(url, options).catch(function (err) {
            /* if the item doesn't include data, the response will be empty
               and the internal call to response.json() will fail */
            var emptyResponseErr = RegExp(/The string did not match the expected pattern|(Unexpected end of (JSON input|data at line 1 column 1))/i);
            /* istanbul ignore else */
            if (emptyResponseErr.test(err.message)) {
                return;
            }
            else
                throw err;
        });
    }
    /**
     * Get the resources associated with an item
     *
     * @param requestOptions - Options for the request
     * @returns A Promise to get some item resources.
     */
    function getItemResources(id, requestOptions) {
        var url = getItemBaseUrl(id, requestOptions) + "/resources";
        // Mix in num:1000 with any user supplied params
        // Key thing - we don't want to mutate the passed in requestOptions
        // as that may be used in other (subsequent) calls in the course
        // of a long promise chains
        var options = __assign({}, requestOptions);
        options.params = __assign({ num: 1000 }, options.params);
        return request(url, options);
    }
    /**
     * ```js
     * import { getItemResource } from "@esri/arcgis-rest-portal";
     *
     * // Parses contents as blob by default
     * getItemResource("3ef", { fileName: "resource.jpg", ...})
     *  .then(resourceContents => {});
     *
     * // Can override parse method
     * getItemResource("3ef", { fileName: "resource.json", readAs: 'json', ...})
     *  .then(resourceContents => {});
     *
     * // Get the response object instead
     * getItemResource("3ef",{ rawResponse: true, fileName: "resource.json" })
     *  .then(response => {})
     * ```
     * Fetches an item resource and optionally parses it to the correct format.
     *
     * Note: provides JSON parse error protection by sanitizing out any unescaped control
     * characters before parsing that would otherwise cause an error to be thrown
     *
     * @param {string} itemId
     * @param {IGetItemResourceOptions} requestOptions
     */
    function getItemResource(itemId, requestOptions) {
        var readAs = requestOptions.readAs || 'blob';
        return getItemFile(itemId, "/resources/" + requestOptions.fileName, readAs, requestOptions);
    }
    // overrides request()'s default behavior for reading the response
    // which is based on `params.f` and defaults to JSON
    // Also adds JSON parse error protection by sanitizing out any unescaped control characters before parsing
    function getItemFile(id, 
    // NOTE: fileName should include any folder/subfolders
    fileName, readMethod, requestOptions) {
        var url = "" + getItemBaseUrl(id, requestOptions) + fileName;
        // preserve escape hatch to let the consumer read the response
        // and ensure the f param is not appended to the query string
        var options = __assign({ params: {} }, requestOptions);
        var justReturnResponse = options.rawResponse;
        options.rawResponse = true;
        options.params.f = null;
        return request(url, options).then(function (response) {
            if (justReturnResponse) {
                return response;
            }
            return readMethod !== 'json'
                ? response[readMethod]()
                : response.text().then(function (text) { return JSON.parse(scrubControlChars(text)); });
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Protect an item. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/protect.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise to protect an item.
     */
    function protectItem(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.id + "/protect";
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { getGroup } from "@esri/arcgis-rest-portal";
     * //
     * getGroup("fxb988") // id
     *   .then(response)
     * ```
     * Fetch a group using its id. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group.htm) for more information.
     *
     * @param id - Group Id
     * @param requestOptions  - Options for the request
     * @returns  A Promise that will resolve with the data from the response.
     */
    function getGroup(id, requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id;
        // default to a GET request
        var options = __assign({ httpMethod: "GET" }, requestOptions);
        return request(url, options);
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Get the User Membership for a particular group. Use this if all you have is the groupId.
     * If you have the group object, check the `userMembership.memberType` property instead of calling this method.
     *
     * @param requestOptions
     * @returns A Promise that resolves with "owner" | "admin" | "member" | "nonmember"
     */
    function getUserMembership(requestOptions) {
        // fetch the group...
        return getGroup(requestOptions.groupId, requestOptions)
            .then(function (group) {
            return group.userMembership.memberType;
        })
            .catch(function () {
            return "none";
        });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { removeItem } from "@esri/arcgis-rest-portal";
     * //
     * removeItem({
     *   id: "3ef",
     *   authentication
     * })
     * ```
     * Delete an item from the portal. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/delete-item.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that deletes an item.
     */
    function removeItem(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.id + "/delete";
            return request(url, requestOptions);
        });
    }
    /**
     * Remove a resource associated with an item
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that deletes an item resource.
     */
    function removeItemResource(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.id + "/removeResources";
            // mix in user supplied params
            requestOptions.params = __assign(__assign({}, requestOptions.params), { resource: requestOptions.resource });
            // only override the deleteAll param specified previously if it is passed explicitly
            if (typeof requestOptions.deleteAll !== "undefined") {
                requestOptions.params.deleteAll = requestOptions.deleteAll;
            }
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2018-2021 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * `SearchQueryBuilder` can be used to construct the `q` param for
     * [`searchItems`](/arcgis-rest-js/api/portal/searchItems#searchItems-search) or
     * [`searchGroups`](/arcgis-rest-js/api/portal/searchGroups#searchGroups-search).
     * By chaining methods, it helps build complex search queries.
     *
     * ```js
     * const startDate = new Date("2020-01-01");
     * const endDate = new Date("2020-09-01");
     * const query = new SearchQueryBuilder()
     *  .match("Patrick")
     *  .in("owner")
     *  .and()
     *  .from(startDate)
     *  .to(endDate)
     *  .in("created")
     *  .and()
     *  .startGroup()
     *    .match("Web Mapping Application")
     *    .in("type")
     *    .or()
     *    .match("Mobile Application")
     *    .in("type")
     *    .or()
     *    .match("Application")
     *    .in("type")
     *  .endGroup()
     *  .and()
     *  .match("Demo App");
     *
     * searchItems(query).then((res) => {
     *   console.log(res.results);
     * });
     * ```
     *
     * Will search for items matching
     * ```
     * "owner: Patrick AND created:[1577836800000 TO 1598918400000] AND (type:"Web Mapping Application" OR type:"Mobile Application" OR type:Application) AND Demo App"
     * ```
     */
    var SearchQueryBuilder = /** @class */ (function () {
        /**
         * @param q An existing query string to start building from.
         */
        function SearchQueryBuilder(q) {
            if (q === void 0) { q = ""; }
            this.termStack = [];
            this.rangeStack = [];
            this.openGroups = 0;
            this.q = q;
        }
        /**
         * Defines strings to search for.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         * ```
         *
         * @param terms strings to search for.
         */
        SearchQueryBuilder.prototype.match = function () {
            var terms = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                terms[_i] = arguments[_i];
            }
            this.termStack = this.termStack.concat(terms);
            return this;
        };
        /**
         * Defines fields to search in. You can pass `"*"` or call this method without arguments to search a default set of fields
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         *   .in("title")
         * ```
         *
         * @param field The field to search for the previous match in.
         */
        SearchQueryBuilder.prototype.in = function (field) {
            var fn = "`in(" + (field ? "\"" + field + "\"" : "") + ")`";
            if (!this.hasRange && !this.hasTerms) {
                warn(
                // apparently-p-rettier-ignore causes some
                fn + " was called with no call to `match(...)` or `from(...)`/`to(...)`. Your query was not modified.");
                return this;
            }
            if (field && field !== "*") {
                this.q += field + ":";
            }
            return this.commit();
        };
        /**
         * Starts a new search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.startGroup = function () {
            this.commit();
            if (this.openGroups > 0) {
                this.q += " ";
            }
            this.openGroups++;
            this.q += "(";
            return this;
        };
        /**
         * Ends a search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.endGroup = function () {
            if (this.openGroups <= 0) {
                warn("`endGroup(...)` was called without calling `startGroup(...)` first. Your query was not modified.");
                return this;
            }
            this.commit();
            this.openGroups--;
            this.q += ")";
            return this;
        };
        /**
         * Joins two sets of queries with an `AND` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .and()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.and = function () {
            return this.addModifier("and");
        };
        /**
         * Joins two sets of queries with an `OR` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.or = function () {
            return this.addModifier("or");
        };
        /**
         * Joins two sets of queries with a `NOT` clause. Another option for filtering results is the [prohibit operator '-'](https://developers.arcgis.com/rest/users-groups-and-items/search-reference.htm#ESRI_SECTION1_5C6C35DB9E4A4F4492C5B937BDA2BF67).
         *
         * ```js
         * // omit results with "Rivers" in their title
         * const query = new SearchQueryBuilder()
         *   .not()
         *   .match("Rivers")
         *   .in("title")
         *
         * // equivalent
         * const query = new SearchQueryBuilder()
         *   .match("Rivers")
         *   .in("-title")
         * ```
         */
        SearchQueryBuilder.prototype.not = function () {
            return this.addModifier("not");
        };
        /**
         * Begins a new range query.
         *
         * ```js
         *
         * const NEWYEARS = new Date("2020-01-01")
         * const TODAY = new Date()
         *
         * const query = new SearchQueryBuilder()
         *   .from(NEWYEARS)
         *   .to(TODAY)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.from = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`from(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\").  Your query was not modified.");
                return this;
            }
            this.rangeStack[0] = term;
            return this;
        };
        /**
         * Ends a range query.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .from(yesterdaysDate)
         *   .to(todaysDate)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.to = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`to(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\"). Your query was not modified.");
                return this;
            }
            this.rangeStack[1] = term;
            return this;
        };
        /**
         * Boosts the previous term to increase its rank in the results.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         *   .boost(3)
         * ```
         */
        SearchQueryBuilder.prototype.boost = function (num) {
            this.commit();
            this.q += "^" + num;
            return this;
        };
        /**
         * Returns the current query string. Called internally when the request is made.
         */
        SearchQueryBuilder.prototype.toParam = function () {
            this.commit();
            this.cleanup();
            return this.q;
        };
        /**
         * Returns a new instance of `SearchQueryBuilder` based on the current instance.
         */
        SearchQueryBuilder.prototype.clone = function () {
            this.commit();
            this.cleanup();
            return new SearchQueryBuilder(this.q + "");
        };
        SearchQueryBuilder.prototype.addModifier = function (modifier) {
            if (this.currentModifer) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "You have called `" + this.currentModifer + "()` after `" + modifier + "()`. Your current query was not modified.");
                return this;
            }
            this.commit();
            if (this.q === "" && modifier !== "not") {
                warn("You have called `" + modifier + "()` without calling another method to modify your query first. Try calling `match()` first.");
                return this;
            }
            this.currentModifer = modifier;
            this.q += this.q === "" ? "" : " ";
            this.q += modifier.toUpperCase() + " ";
            return this;
        };
        SearchQueryBuilder.prototype.needsQuotes = function (s) {
            return /\s|:/g.test(s);
        };
        SearchQueryBuilder.prototype.formatTerm = function (term) {
            if (term instanceof Date) {
                return term.getTime();
            }
            if (typeof term === "string" && this.needsQuotes(term)) {
                return "\"" + term + "\"";
            }
            return term;
        };
        SearchQueryBuilder.prototype.commit = function () {
            var _this = this;
            this.currentModifer = undefined;
            if (this.hasRange) {
                this.q += "[" + this.formatTerm(this.rangeStack[0]) + " TO " + this.formatTerm(this.rangeStack[1]) + "]";
                this.rangeStack = [undefined, undefined];
            }
            if (this.hasTerms) {
                this.q += this.termStack
                    .map(function (term) {
                    return _this.formatTerm(term);
                })
                    .join(" ");
                this.termStack = [];
            }
            return this;
        };
        Object.defineProperty(SearchQueryBuilder.prototype, "hasTerms", {
            get: function () {
                return this.termStack.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SearchQueryBuilder.prototype, "hasRange", {
            get: function () {
                return this.rangeStack.length && this.rangeStack[0] && this.rangeStack[1];
            },
            enumerable: false,
            configurable: true
        });
        SearchQueryBuilder.prototype.cleanup = function () {
            // end a group if we have started one
            if (this.openGroups > 0) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "Automatically closing " + this.openGroups + " group(s). You can use `endGroup(...)` to remove this warning.");
                while (this.openGroups > 0) {
                    this.q += ")";
                    this.openGroups--;
                }
            }
            var oldQ = this.q;
            this.q = oldQ.replace(/( AND ?| NOT ?| OR ?)*$/, "");
            if (oldQ !== this.q) {
                warn("`startGroup(...)` was called without calling `endGroup(...)` first. Your query was not modified.");
            }
            // clear empty groups
            this.q = this.q.replace(/(\(\))*/, "");
        };
        return SearchQueryBuilder;
    }());

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    function genericSearch(search, searchType) {
        var options;
        if (typeof search === "string" || search instanceof SearchQueryBuilder) {
            options = {
                httpMethod: "GET",
                params: {
                    q: search,
                },
            };
        }
        else {
            // searchUserAccess has one (knonw) valid value: "groupMember"
            options = appendCustomParams(search, [
                "q",
                "num",
                "start",
                "sortField",
                "sortOrder",
                "searchUserAccess",
                "searchUserName",
                "filter",
                "countFields",
                "countSize",
                "categories",
                "categoryFilters",
            ], {
                httpMethod: "GET",
            });
        }
        var path;
        switch (searchType) {
            case "item":
                path = "/search";
                break;
            case "group":
                path = "/community/groups";
                break;
            case "groupContent":
                // Need to have groupId property to do group contents search,
                // cso filter out all but ISearchGroupContentOptions
                if (typeof search !== "string" &&
                    !(search instanceof SearchQueryBuilder) &&
                    search.groupId) {
                    path = "/content/groups/" + search.groupId + "/search";
                }
                else {
                    return Promise.reject(new Error("you must pass a `groupId` option to `searchGroupContent`"));
                }
                break;
            default:
                // "users"
                path = "/portals/self/users/search";
                break;
        }
        var url = getPortalUrl(options) + path;
        // send the request
        return request(url, options).then(function (r) {
            if (r.nextStart && r.nextStart !== -1) {
                r.nextPage = function () {
                    var newOptions;
                    if (typeof search === "string" ||
                        search instanceof SearchQueryBuilder) {
                        newOptions = {
                            q: search,
                            start: r.nextStart,
                        };
                    }
                    else {
                        newOptions = search;
                        newOptions.start = r.nextStart;
                    }
                    return genericSearch(newOptions, searchType);
                };
            }
            return r;
        });
    }

    /* Copyright (c) 2018-2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { searchItems } from "@esri/arcgis-rest-portal";
     * //
     * searchItems('water')
     *   .then(response) // response.total => 355
     * ```
     * Search a portal for items. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/search.htm) for more information.
     *
     * @param search - A string or RequestOptions object to pass through to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function searchItems(search) {
        return genericSearch(search, "item");
    }

    /* Copyright (c) 2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    function chunk(array, size) {
        if (array.length === 0) {
            return [];
        }
        var chunks = [];
        for (var i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { addGroupUsers } from "@esri/arcgis-rest-portal";
     * //
     * addGroupUsers({
     *   id: groupId,
     *   users: ["username1", "username2"],
     *   admins: ["username3"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Add users to a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-users-to-group.htm) for more information.
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function addGroupUsers(requestOptions) {
        var id = requestOptions.id;
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id + "/addUsers";
        var baseOptions = Object.assign({}, requestOptions, {
            admins: undefined,
            users: undefined
        });
        var batchRequestOptions = __spreadArrays(_prepareRequests("users", requestOptions.users, baseOptions), _prepareRequests("admins", requestOptions.admins, baseOptions));
        var promises = batchRequestOptions.map(function (options) {
            return _sendSafeRequest(url, options);
        });
        return Promise.all(promises).then(_consolidateRequestResults);
    }
    function _prepareRequests(type, usernames, baseOptions) {
        if (!usernames || usernames.length < 1) {
            return [];
        }
        // the ArcGIS REST API only allows to add no more than 25 users per request,
        // see https://developers.arcgis.com/rest/users-groups-and-items/add-users-to-group.htm
        var userChunks = chunk(usernames, 25);
        return userChunks.map(function (users) {
            return _generateRequestOptions(type, users, baseOptions);
        });
    }
    function _generateRequestOptions(type, usernames, baseOptions) {
        var _a, _b;
        return Object.assign({}, baseOptions, (_a = {},
            _a[type] = usernames,
            _a.params = __assign(__assign({}, baseOptions.params), (_b = {}, _b[type] = usernames, _b)),
            _a));
    }
    // this request is safe since the request error will be handled
    function _sendSafeRequest(url, requestOptions) {
        return request(url, requestOptions).catch(function (error) {
            return {
                errors: [error]
            };
        });
    }
    function _consolidateRequestResults(results) {
        var notAdded = results
            .filter(function (result) { return result.notAdded; })
            .reduce(function (collection, result) { return collection.concat(result.notAdded); }, []);
        var errors = results
            .filter(function (result) { return result.errors; })
            .reduce(function (collection, result) { return collection.concat(result.errors); }, []);
        var consolidated = { notAdded: notAdded };
        if (errors.length > 0) {
            consolidated.errors = errors;
        }
        return consolidated;
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { removeGroupUsers } from "@esri/arcgis-rest-portal";
     * //
     * removeGroupUsers({
     *   id: groupId,
     *   users: ["username1", "username2"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Add users to a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/remove-users-from-group.htm) for more information.
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function removeGroupUsers(requestOptions) {
        var id = requestOptions.id, usersToRemove = requestOptions.users;
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id + "/removeUsers";
        var safeSend = function (users) {
            var options = __assign(__assign({}, requestOptions), { users: users, params: { users: users } });
            return request(url, options)
                .catch(function (error) { return ({ errors: [error] }); });
        };
        // the ArcGIS REST API only allows to add no more than 25 users per request,
        // see https://developers.arcgis.com/rest/users-groups-and-items/remove-users-from-group.htm
        var promises = chunk(usersToRemove, 25).map(function (usersChunk) { return safeSend(usersChunk); });
        return Promise.all(promises)
            .then(function (results) {
            var filtered = function (propName) { return results
                .filter(function (result) { return result[propName]; })
                .reduce(function (collection, result) { return collection.concat(result[propName]); }, []); };
            var errors = filtered('errors');
            var consolidated = { notRemoved: filtered('notRemoved') };
            return errors.length ? __assign(__assign({}, consolidated), { errors: errors }) : consolidated;
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { updateGroup } from '@esri/arcgis-rest-portal';
     * //
     * updateGroup({
     *   group: { id: "fgr344", title: "new" }
     * })
     *   .then(response)
     * ```
     * Update the properties of a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/update-group.htm) for more information.
     *
     * @param requestOptions - Options for the request, including the group
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function updateGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.group.id + "/update";
        requestOptions.params = __assign(__assign({}, requestOptions.params), requestOptions.group);
        return request(url, requestOptions);
    }

    /**
     * ```js
     * import { updateUserMemberships } from "@esri/arcgis-rest-portal";
     * //
     * updateUserMemberships({
     *   id: groupId,
     *   admins: ["username3"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Change the user membership levels of existing users in a group
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function updateUserMemberships(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/updateUsers";
        var opts = {
            authentication: requestOptions.authentication,
            params: {}
        };
        // add the correct params depending on the type of membership we are changing to
        if (requestOptions.newMemberType === "admin") {
            opts.params.admins = requestOptions.users;
        }
        else {
            opts.params.users = requestOptions.users;
        }
        // make the request
        return request(url, opts);
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { getUser } from '@esri/arcgis-rest-portal';
     * //
     * getUser("jsmith")
     *   .then(response)
     * // => { firstName: "John", lastName: "Smith",tags: ["GIS Analyst", "City of Redlands"] }
     * ```
     * Get information about a user. This method has proven so generically useful that you can also call [`UserSession.getUser()`](/arcgis-rest-js/api/auth/UserSession#getUser-summary).
     *
     * @param requestOptions - options to pass through in the request
     * @returns A Promise that will resolve with metadata about the user
     */
    function getUser(requestOptions) {
        var url;
        var options = { httpMethod: "GET" };
        // if a username is passed, assume ArcGIS Online
        if (typeof requestOptions === "string") {
            url = "https://www.arcgis.com/sharing/rest/community/users/" + requestOptions;
        }
        else {
            // if an authenticated session is passed, default to that user/portal unless another username is provided manually
            var username = requestOptions.username || requestOptions.authentication.username;
            url = getPortalUrl(requestOptions) + "/community/users/" + encodeURIComponent(username);
            options = __assign(__assign({}, requestOptions), options);
        }
        // send the request
        return request(url, options);
    }

    /**
     * ```js
     * import { isItemSharedWithGroup } from "@esri/arcgis-rest-portal";
     * //
     * isItemSharedWithGroup({
     *   groupId: 'bc3,
     *   itemId: 'f56,
     *   authentication
     * })
     * .then(isShared => {})
     * ```
     * Find out whether or not an item is already shared with a group.
     *
     * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.
     * @returns Promise that will resolve with true/false
     */
    function isItemSharedWithGroup(requestOptions) {
        var searchOpts = {
            q: "id: " + requestOptions.id + " AND group: " + requestOptions.groupId,
            start: 1,
            num: 10,
            sortField: "title",
            authentication: requestOptions.authentication,
            httpMethod: "POST"
        };
        return searchItems(searchOpts).then(function (searchResponse) {
            var result = false;
            if (searchResponse.total > 0) {
                result = searchResponse.results.some(function (itm) {
                    return itm.id === requestOptions.id;
                });
                return result;
            }
        });
    }

    /**
     * ```js
     * import { shareItemWithGroup } from '@esri/arcgis-rest-portal';
     * //
     * shareItemWithGroup({
     *   id: "abc123",
     *   groupId: "xyz987",
     *   owner: "some-owner",
     *   authentication
     * })
     * ```
     * Share an item with a group, either as an
     * [item owner](https://developers.arcgis.com/rest/users-groups-and-items/share-item-as-item-owner-.htm),
     * [group admin](https://developers.arcgis.com/rest/users-groups-and-items/share-item-as-group-admin-.htm) or
     * organization admin.
     *
     * Note: Sharing the item as an Admin will use the `/content/users/:ownername/items/:itemid/share` end-point
     *
     * @param requestOptions - Options for the request.
     * @returns A Promise that will resolve with the data from the response.
     */
    function shareItemWithGroup(requestOptions) {
        return isItemSharedWithGroup(requestOptions)
            .then(function (isShared) {
            if (isShared) {
                // already shared, exit early with success response
                return {
                    itemId: requestOptions.id,
                    shortcut: true,
                    notSharedWith: [],
                };
            }
            var username = requestOptions.authentication.username, owner = requestOptions.owner, confirmItemControl = requestOptions.confirmItemControl;
            var itemOwner = owner || username;
            // non-item owner
            if (itemOwner !== username) {
                // need to track if the user is an admin
                var isAdmin_1 = false;
                // track if the admin & owner are in the same org
                var isCrossOrgSharing_1 = false;
                // next perform any necessary membership adjustments for
                // current user and/or item owner
                return Promise.all([
                    getUser({
                        username: username,
                        authentication: requestOptions.authentication,
                    }),
                    getUser({
                        username: itemOwner,
                        authentication: requestOptions.authentication,
                    }),
                    getUserMembership(requestOptions),
                ])
                    .then(function (_a) {
                    var currentUser = _a[0], ownerUser = _a[1], membership = _a[2];
                    var isSharedEditingGroup = !!confirmItemControl;
                    isAdmin_1 = currentUser.role === "org_admin" && !currentUser.roleId;
                    isCrossOrgSharing_1 = currentUser.orgId !== ownerUser.orgId;
                    return getMembershipAdjustments(currentUser, isSharedEditingGroup, membership, isAdmin_1, ownerUser, requestOptions);
                })
                    .then(function (membershipAdjustments) {
                    var _a = membershipAdjustments[0], revert = (_a === void 0 ? {
                        promise: Promise.resolve({ notAdded: [] }),
                        revert: function (sharingResults) {
                            return Promise.resolve(sharingResults);
                        },
                    } : _a).revert;
                    // perform all membership adjustments
                    return Promise.all(membershipAdjustments.map(function (_a) {
                        var promise = _a.promise;
                        return promise;
                    }))
                        .then(function () {
                        // then attempt the share
                        return shareToGroup(requestOptions, isAdmin_1, isCrossOrgSharing_1);
                    })
                        .then(function (sharingResults) {
                        // lastly, if the admin user was added to the group,
                        // remove them from the group. this is a no-op that
                        // immediately resolves the sharingResults when no
                        // membership adjustment was needed
                        return revert(sharingResults);
                    });
                });
            }
            // item owner, let it call through
            return shareToGroup(requestOptions);
        })
            .then(function (sharingResponse) {
            if (sharingResponse.notSharedWith.length) {
                throw Error("Item " + requestOptions.id + " could not be shared to group " + requestOptions.groupId + ".");
            }
            else {
                // all is well
                return sharingResponse;
            }
        });
    }
    function getMembershipAdjustments(currentUser, isSharedEditingGroup, membership, isAdmin, ownerUser, requestOptions) {
        var membershipGuarantees = [];
        if (requestOptions.groupId !== currentUser.favGroupId) {
            if (isSharedEditingGroup) {
                if (!isAdmin) {
                    // abort and reject promise
                    throw Error("This item can not be shared to shared editing group " + requestOptions.groupId + " by " + currentUser.username + " as they not the item owner or org admin.");
                }
                membershipGuarantees.push(
                // admin user must be a group member to share, should be reverted afterwards
                ensureMembership(currentUser, currentUser, false, "Error adding " + currentUser.username + " as member to edit group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group.", requestOptions), 
                // item owner must be a group admin
                ensureMembership(currentUser, ownerUser, true, membership === "none"
                    ? "Error adding user " + ownerUser.username + " to edit group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group."
                    : "Error promoting user " + ownerUser.username + " to admin in edit group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group.", requestOptions));
            }
            else if (isAdmin) {
                // admin user must be a group member to share, should be reverted afterwards
                membershipGuarantees.push(ensureMembership(currentUser, currentUser, false, "Error adding " + currentUser.username + " as member to view group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " was not shared to the group.", requestOptions));
            }
            else if (membership === "none") {
                // all other non-item owners must be a group member
                throw new Error("This item can not be shared by " + currentUser.username + " as they are not a member of the specified group " + requestOptions.groupId + ".");
            }
        }
        return membershipGuarantees;
    }
    function shareToGroup(requestOptions, isAdmin, isCrossOrgSharing) {
        if (isAdmin === void 0) { isAdmin = false; }
        if (isCrossOrgSharing === void 0) { isCrossOrgSharing = false; }
        var username = requestOptions.authentication.username;
        var itemOwner = requestOptions.owner || username;
        // decide what url to use
        // default to the non-owner url...
        var url = getPortalUrl(requestOptions) + "/content/items/" + requestOptions.id + "/share";
        // but if they are the owner, or org_admin, use this route
        // Note: When using this end-point as an admin, apparently the admin does not need to be a member of the group (the itemOwner does)
        // Note: Admin's can only use this route when the item is in the same org they are admin for
        if (itemOwner === username || (isAdmin && !isCrossOrgSharing)) {
            url = getPortalUrl(requestOptions) + "/content/users/" + itemOwner + "/items/" + requestOptions.id + "/share";
        }
        // now its finally time to do the sharing
        requestOptions.params = {
            groups: requestOptions.groupId,
            confirmItemControl: requestOptions.confirmItemControl,
        };
        return request(url, requestOptions);
    }
    function ensureMembership(currentUser, ownerUser, shouldPromote, errorMessage, requestOptions) {
        var _a;
        var ownerGroups = ownerUser.groups || [];
        var group = ownerGroups.find(function (g) {
            return g.id === requestOptions.groupId;
        });
        // if they are in different orgs, eject
        if (currentUser.orgId !== ownerUser.orgId) {
            throw Error("User " + ownerUser.username + " is not a member of the same org as " + currentUser.username + ". Consequently they can not be added added to group " + requestOptions.groupId + " nor can item " + requestOptions.id + " be shared to the group.");
        }
        // if owner is not a member, and has 512 groups
        if (!group && ownerGroups.length > 511) {
            throw Error("User " + ownerUser.username + " already has 512 groups, and can not be added to group " + requestOptions.groupId + ". Consequently item " + requestOptions.id + " can not be shared to the group.");
        }
        var promise;
        var revert;
        // decide if we need to add them or upgrade them
        if (group) {
            // they are in the group...
            // check member type
            if (shouldPromote && group.userMembership.memberType === "member") {
                // promote them
                promise = updateUserMemberships({
                    id: requestOptions.groupId,
                    users: [ownerUser.username],
                    newMemberType: "admin",
                    authentication: requestOptions.authentication,
                })
                    .then(function (results) {
                    // convert the result into the right type
                    var notAdded = results.results.reduce(function (acc, entry) {
                        if (!entry.success) {
                            acc.push(entry.username);
                        }
                        return acc;
                    }, []);
                    // and return it
                    return Promise.resolve({ notAdded: notAdded });
                })
                    .catch(function () { return ({ notAdded: [ownerUser.username] }); });
                revert = function (sharingResults) {
                    return updateUserMemberships({
                        id: requestOptions.groupId,
                        users: [ownerUser.username],
                        newMemberType: "member",
                        authentication: requestOptions.authentication,
                    })
                        .then(function () { return sharingResults; })
                        .catch(function () { return sharingResults; });
                };
            }
            else {
                // they are already an admin in the group
                // return the same response the API would if we added them
                promise = Promise.resolve({ notAdded: [] });
                revert = function (sharingResults) { return Promise.resolve(sharingResults); };
            }
        }
        else {
            // attempt to add user to group
            var userType = shouldPromote ? "admins" : "users";
            // can't currently determine if the group is within the admin's
            // org without performing a search, so attempt to add and handle
            // the api error
            promise = addGroupUsers((_a = {
                    id: requestOptions.groupId
                },
                _a[userType] = [ownerUser.username],
                _a.authentication = requestOptions.authentication,
                _a))
                .then(function (results) {
                // results.errors includes an ArcGISAuthError when the group
                // is in a different org, but notAdded is empty, throw here
                // to normalize the results in below catch
                if (results.errors && results.errors.length) {
                    throw results.errors[0];
                }
                return results;
            })
                .catch(function () { return ({ notAdded: [ownerUser.username] }); });
            revert = function (sharingResults) {
                return removeGroupUsers({
                    id: requestOptions.groupId,
                    users: [ownerUser.username],
                    authentication: requestOptions.authentication,
                }).then(function () {
                    // always resolves, suppress any resolved errors
                    return sharingResults;
                });
            };
        }
        return {
            promise: promise.then(function (membershipResponse) {
                if (membershipResponse.notAdded.length) {
                    throw new Error(errorMessage);
                }
                return membershipResponse;
            }),
            revert: revert,
        };
    }

    /**
     * Remove a Page Item. This deletes the item.
     * @param {Object | String} idOrModel Model object or Item Id
     * @param {IRequestOptions} requestOptions
     */
    function removePage(idOrModel, requestOptions) {
        var modelPromise = Promise.resolve(idOrModel);
        if (typeof idOrModel === "string") {
            modelPromise = hubCommon.getModel(idOrModel, requestOptions);
        }
        var pageModel;
        // fire it to get the model...
        return modelPromise
            .then(function (model) {
            pageModel = model;
            // get the id's of the sites this page is linked to...
            var linkedSites = hubCommon.mapBy("id", hubCommon.getWithDefault(pageModel, "data.values.sites", []));
            // we need to unlink the page from all sites. However, these calls *could* fail
            // if the current user lacks rights to save the site item, so we just make sure these
            // always resolve. In the Ember service code, we used `allSettled` but that's RSVP special sauce
            var failSafeUnlink = hubCommon.failSafe(unlinkSiteAndPage);
            return Promise.all(linkedSites.map(function (siteId) {
                var opts = Object.assign({
                    pageModel: pageModel,
                    siteId: siteId,
                }, requestOptions);
                return failSafeUnlink(opts);
            }));
        })
            .then(function () {
            return hubCommon.unprotectModel(pageModel, requestOptions);
        })
            .then(function () {
            var opts = Object.assign({ id: pageModel.item.id }, requestOptions);
            return removeItem(opts);
        });
    }

    /**
     * Update a Page item
     * @param {Object} model Page Model
     * @param {IUpdatePageOptions} updateSiteOptions
     *
     * This function supports the equivalent of a PATCH REST operation
     * It will fetch the current item from ago, and then apply
     * a subset of property changes to the model if a patchList is included.
     * The patchList can include any property paths on the item.
     * If the list is empty, then the entire page model is overwritten.
     * TODO: Add calls to remove unused image resources
     */
    function updatePage(model, updateSiteOptions) {
        var patchList = Array.isArray(updateSiteOptions.allowList)
            ? updateSiteOptions.allowList
            : [];
        // store info about last update and who did it
        model.data.values.updatedAt = new Date().toISOString();
        model.data.values.updatedBy = updateSiteOptions.authentication.username;
        // nuke out the url property just for good measure
        model.item.url = "";
        var prms = Promise.resolve(model);
        if (patchList.length) {
            prms = hubCommon.getModel(hubCommon.getProp(model, "item.id"), updateSiteOptions);
        }
        return prms.then(function (modelFromAGO) {
            if (patchList.length) {
                // "patch" operation
                model = hubCommon.mergeObjects(model, modelFromAGO, patchList);
            }
            // update it
            var opts = Object.assign({ item: hubCommon.serializeModel(model) }, updateSiteOptions);
            opts.params = { clearEmptyFields: true };
            return updateItem(opts);
        });
    }

    /**
     * Get the correct url used to edit the page
     * @param item the page item
     * @param isPortal from appSettings.isPortal
     * @param siteUrl the url of the parent site
     */
    function getPageEditUrl(item, isPortal, siteUrl) {
        var prefix = "";
        if (isPortal) {
            prefix = siteUrl;
        }
        return prefix + "/edit?pageId=" + item.id;
    }

    function getPaths(componentName) {
        switch (componentName) {
            case "webmap-card":
                return ["component.settings.webmap"];
            case "survey-card":
                return ["component.settings.surveyId"];
            case "app-card":
                return ["component.settings.itemId"];
            case "summary-statistic-card":
                return ["component.settings.itemId"];
            case "items/gallery-card":
                return ["component.settings.ids"];
            default:
                return [];
        }
    }
    /**
     * Find all the paths dependencies for the given card
     *
     * @param {ICard} card
     */
    function getCardDependencies(card) {
        var componentName = hubCommon.getProp(card, "component.name");
        var paths = getPaths(componentName);
        return paths.reduce(collectAndFlattenPropertyValues(card), []);
    }
    function collectAndFlattenPropertyValues(card) {
        return function (acc, path) {
            var propertyValue = hubCommon.getProp(card, path);
            if (!propertyValue) {
                return acc;
            }
            if (Array.isArray(propertyValue)) {
                return acc.concat(propertyValue);
            }
            else {
                return acc.concat([propertyValue]);
            }
        };
    }

    /**
     * Find all the cards for the given row
     *
     * @param {IRow} row
     */
    function getRowDependencies(row) {
        return row.cards.reduce(function (deps, card) {
            var cardDeps = getCardDependencies(card);
            if (cardDeps.length) {
                deps = deps.concat(cardDeps);
            }
            return deps;
        }, []);
    }

    /**
     * Find all the row and card dependencies for the given section
     *
     * @param {ISection} section
     */
    function getSectionDependencies(section) {
        return section.rows.reduce(function (deps, row) {
            return deps.concat(getRowDependencies(row));
        }, []);
    }

    /**
     * Find all the section/row/card dependencies for the given layout
     *
     * @param {ILayout} layout
     */
    function getLayoutDependencies(layout) {
        return layout.sections.reduce(function (deps, section) {
            return deps.concat(getSectionDependencies(section));
        }, []);
    }

    /**
     * Return a list of items this page depends on
     */
    function getPageDependencies(model) {
        var layout = hubCommon.getWithDefault(model, "data.values.layout", {});
        return getLayoutDependencies(layout);
    }

    /**
     * The item type depends if the app is running
     * in ArcGIS Enterprise vs AGO
     * @param {boolean} isPortal Is this running in Enterprise?
     */
    function getPageItemType(isPortal) {
        var type = "Hub Page";
        if (isPortal) {
            type = "Site Page";
        }
        return type;
    }

    var PAGE_TYPE_KEYWORD = "hubPage";

    /**
     * Given a Page Model, ensure that it has all the requires properties set correctly
     * and return a new object
     * @param {Object} pageModel Page Model object
     * @param {Object} options {username, isPortal}
     */
    function ensureRequiredPageProperties(pageModel, options) {
        // clone
        var result = hubCommon.cloneObject(pageModel);
        result.item.owner = options.username;
        result.item.access = "private";
        if (!result.data.values) {
            result.data.values = {};
        }
        result.data.values.updatedAt = new Date().toISOString();
        result.data.values.updatedBy = options.username;
        if (!result.data.values.sites) {
            result.data.values.sites = [];
        }
        // NOTE: until we have hub-home, we are setting the page url to ''
        if (result.item.url) {
            result.item.url = "";
        }
        result.item.type = getPageItemType(options.isPortal);
        // ensure it has the typeKeyword
        if (result.item.typeKeywords.indexOf(PAGE_TYPE_KEYWORD) === -1) {
            result.item.typeKeywords.push(PAGE_TYPE_KEYWORD);
        }
        return result;
    }

    var PAGE_TEMPLATE_KEYWORD = "hubPageTemplate";

    /**
     * Link a Page and a Site, or vice-versa
     * This is a super tolerant function. It can be passed id's, models or a mix.
     * It will handle either the site or the page items being missing
     * It will handle cases where the current user lacks update privs to either item or rights
     * to change the sharing. Of course in those cases we clearly can't make the changes, and
     * this function will resolve as though they were made, usually the UI tier will have
     * ensured that the current user has write access to at least one of the main entities
     * @param {ILinkPageAndSiteRequestOptions} linkRequestOptions {siteModel || siteId, pageModel || pageId, authorization }
     */
    function linkSiteAndPage(linkRequestOptions) {
        var shareGroups = [];
        var promises = [];
        var pageModel;
        var siteModel;
        var requestOptions = { authentication: linkRequestOptions.authentication };
        // get the models from the options...
        return Promise.all([
            hubCommon.getModelFromOptions("page", linkRequestOptions),
            hubCommon.getModelFromOptions("site", linkRequestOptions)
        ])
            .then(function (models) {
            // Should we handle either item being inaccessible?
            pageModel = models[0], siteModel = models[1];
            if (!siteModel.isMissing && !pageModel.isMissing) {
                // ensure we actually got a page and site
                if (!isSite(siteModel.item) ||
                    !hubCommon.includes(["Hub Page", "Site Page"], pageModel.item.type)) {
                    return Promise.resolve([]);
                }
                // if we got a both...
                // Link the Site into the Page...
                var siteEntry = {
                    id: siteModel.item.id,
                    title: siteModel.item.title
                };
                if (!hubCommon.getProp(pageModel, "data.values.sites")) {
                    hubCommon.deepSet(pageModel, "data.values.sites", []);
                }
                var sites = hubCommon.getProp(pageModel, "data.values.sites");
                var hasSiteAlready = hubCommon.includes(sites.map(function (p) { return p.id; }), siteEntry.id);
                if (!hasSiteAlready) {
                    pageModel.data.values.sites.push(siteEntry);
                    var opts = Object.assign({ item: hubCommon.serializeModel(pageModel) }, requestOptions);
                    // Not failsafe - could reject
                    promises.push(updateItem(opts));
                }
                // Link the Page into the Site
                var pageEntry = {
                    id: pageModel.item.id,
                    title: pageModel.item.title
                };
                if (!hubCommon.getProp(siteModel, "data.values.pages")) {
                    hubCommon.deepSet(siteModel, "data.values.pages", []);
                }
                var pages = hubCommon.getProp(siteModel, "data.values.pages");
                var hasPageAlready = hubCommon.includes(pages.map(function (p) { return p.id; }), pageEntry.id);
                if (!hasPageAlready) {
                    var slugs = hubCommon.mapBy("slug", pages);
                    // use the passed in slug, or generate a unique slug and add to the page entry...
                    pageEntry.slug =
                        linkRequestOptions.pageSlug ||
                            hubCommon.ensureUniqueString(slugs, hubCommon.slugify(pageEntry.title));
                    // push entry into pages array...
                    siteModel.data.values.pages.push(pageEntry);
                    // update the site item...
                    var opts = Object.assign({ item: hubCommon.serializeModel(siteModel) }, requestOptions);
                    // Not failsafe - could reject
                    promises.push(updateItem(opts));
                }
                // Now we need to handle sharing of the Page to the site Collab & Content groups
                // The share functions handle pre-flights so we don't need to be concerned if the page is
                // somehow already shared to the group.
                shareGroups = hubCommon.maybePush(hubCommon.getProp(siteModel, "item.properties.collaborationGroupId"), shareGroups);
                shareGroups = hubCommon.maybePush(hubCommon.getProp(siteModel, "item.properties.contentGroupId"), shareGroups);
                // NOTE: Since sharing is limited to the owner || admin we failSafe the calls, and hope for the best.
                var failSafeShare = hubCommon.failSafe(hubCommon.shareItemToGroups);
                promises.push(failSafeShare(pageEntry.id, shareGroups, requestOptions));
                // return all the promises...
                return Promise.all(promises);
            }
            else {
                var msg = "The Page item (" + pageModel.item.id + ") is inaccessible.";
                if (siteModel.isMissing) {
                    if (pageModel.isMissing) {
                        msg = "Both the Page item (" + pageModel.item.id + ") and the Site item (" + siteModel.item.id + ") are inaccssible";
                    }
                    else {
                        msg = "The Site item (" + siteModel.item.id + ") is inaccessible.";
                    }
                }
                throw new Error("Linking Failed: " + msg);
            }
        })
            .then(function () {
            // Downside of optionally pusing entries into a promise array, is that you don't really know
            // what is in what index, so we really can't use the return values...
            return {
                pageModel: pageModel,
                siteModel: siteModel
            };
        })
            .catch(function (err) {
            throw Error("Error occured linking site " + siteModel.item.id + " with " + pageModel.item.id + ": " + err);
        });
    }

    /**
     * Given a Page model, create the item, protect it, share it, connect it to the site
     * and upload any resources.
     * @param {Object} model Page model to be created as an Item
     * @param {Object} options object containing shareTo, and space for future additions
     * @param {IHubRequestOptions} hubRequestOptions IRequestOptions object, with isPortal
     */
    function createPage(model, options, hubRequestOptions) {
        // ensure we got authentication
        if (!hubRequestOptions.authentication) {
            throw new Error("createPage must be passed hubRequestOptions.authentication");
        }
        // ensure props
        var newPage = ensureRequiredPageProperties(model, {
            username: hubRequestOptions.authentication.username,
            isPortal: hubRequestOptions.isPortal
        });
        // convert to a flat object w. .data --> .text as a json string
        var serializedModel = hubCommon.serializeModel(newPage);
        // create the item
        return createItem({
            item: serializedModel,
            owner: newPage.item.owner,
            authentication: hubRequestOptions.authentication
        })
            .then(function (createResponse) {
            // hold onto the Id so we can return a complete model
            newPage.item.id = createResponse.id;
            // protect it
            return protectItem({
                id: newPage.item.id,
                owner: newPage.item.owner,
                authentication: hubRequestOptions.authentication
            });
        })
            .then(function (protectReponse) {
            // share to any groups
            var sharingPromises = [];
            if (Array.isArray(options.shareTo) && options.shareTo.length) {
                // map over the array sharing the item to all groups
                sharingPromises = options.shareTo.map(function (groupInfo) {
                    return shareItemWithGroup({
                        id: newPage.item.id,
                        groupId: groupInfo.id,
                        authentication: hubRequestOptions.authentication,
                        confirmItemControl: groupInfo.confirmItemControl || false
                    });
                });
                newPage.item.access = "shared";
            }
            return Promise.all(sharingPromises);
        })
            .then(function (response) {
            // link page to sites
            var sites = hubCommon.getWithDefault(newPage, "data.values.sites", []);
            var requestOptions = {
                authentication: hubRequestOptions.authentication
            };
            return Promise.all(sites.map(function (entry) {
                var opts = Object.assign({
                    siteId: entry.id,
                    pageModel: newPage
                }, requestOptions);
                return linkSiteAndPage(opts);
            }));
        })
            .then(function (siteLinkingResponse) {
            // upload resources
            var assets = hubCommon.getWithDefault(options, "assets", []);
            return hubCommon.uploadResourcesFromUrl(newPage, assets, hubRequestOptions);
        })
            .then(function () { return newPage; })
            .catch(function (err) {
            throw Error("createPage: Error creating page: " + err);
        });
    }

    /**
     * Traverse the layout graph, locating any cards that may have image resources
     * returning an array containing the resource information.
     * @param {Object} layout the layout to extract image cropIds from
     * @private
     */
    function _getImageCropIdsFromLayout(layout) {
        var imgAssets = [];
        var headerLogo = hubCommon.getProp(layout, "header.component.settings.logo");
        if (headerLogo && headerLogo.cropId) {
            imgAssets.push(headerLogo);
        }
        var sections = hubCommon.getProp(layout, "sections") || [];
        return sections
            .reduce(collectSectionAssets, imgAssets)
            .filter(hasCropId)
            .map(extractCropId);
    }
    function collectSectionAssets(assets, section) {
        var sectionAssets = section.rows
            .reduce(collectCards, [])
            .filter(isImageOrJumbotronCard)
            .map(extractSettingsProperty);
        // retain crop info if section has an image background
        if (hubCommon.getProp(section, "style.background.cropSrc")) {
            sectionAssets.unshift(section.style.background);
        }
        return assets.concat(sectionAssets);
    }
    function collectCards(acc, row) {
        return acc.concat(row.cards);
    }
    function isImageOrJumbotronCard(card) {
        return ["image-card", "jumbotron-card"].indexOf(card.component.name) > -1;
    }
    function extractSettingsProperty(card) {
        return card.component.settings;
    }
    function hasCropId(entry) {
        return !!entry.cropId;
    }
    function extractCropId(entry) {
        return entry.cropId;
    }

    var converters = {
        "event-list-card": convertEventListCard,
        "follow-initiative-card": convertFollowCard,
        "items/gallery-card": convertItemGalleryCard,
        "image-card": convertImageCard,
        "jumbotron-card": convertImageCard
    };
    /**
     * Convert a card to a templatized version of itself
     * @param {ICard} card the card to templatize
     */
    function convertCard(card) {
        var clone = hubCommon.cloneObject(card);
        var converter = converters[clone.component.name];
        if (converter) {
            return converter(clone);
        }
        return {
            card: clone,
            assets: []
        };
    }
    function convertEventListCard(card) {
        card.component.settings.initiativeIds = ["{{initiative.item.id}}"];
        return { card: card, assets: [] };
    }
    function convertFollowCard(card) {
        card.component.settings.initiativeId = "{{initiative.item.id}}";
        return { card: card, assets: [] };
    }
    function convertImageCard(card) {
        var result = {
            card: card,
            assets: []
        };
        if (hubCommon.getProp(card, "component.settings.fileSrc")) {
            result.assets.push(card.component.settings.fileSrc);
        }
        if (hubCommon.getProp(card, "component.settings.cropSrc")) {
            result.assets.push(card.component.settings.cropSrc);
        }
        return result;
    }
    function convertItemGalleryCard(card) {
        var settings = card.component.settings;
        var version = hubCommon.getProp(settings, "version");
        if (hubCommon.getProp(settings, "groups") && version < 4) {
            settings.groups = [
                {
                    title: "{{solution.title}}",
                    id: "{{teams.contentGroupId}}"
                }
            ];
        }
        if (hubCommon.getProp(settings, "query.groups")) {
            if (version >= 4) {
                settings.query.groups = ["{{teams.contentGroupId}}"];
            }
            else {
                settings.query.groups = [
                    {
                        title: "{{solution.title}}",
                        id: "{{teams.contentGroupId}}"
                    }
                ];
            }
        }
        if (hubCommon.getProp(settings, "query.orgId")) {
            settings.query.orgId = "{{organization.id}}";
        }
        if (hubCommon.getProp(settings, "orgId")) {
            settings.orgId = "{{organization.id}}";
        }
        if (settings.siteId) {
            settings.siteId = "{{appid}}";
        }
        return { card: card, assets: [] };
    }

    /**
     * Convert a row, collecting assets along the way...
     * @param {IRow} row the row to templatize
     */
    function convertRow(row) {
        // if the section has a background image, and it has a url, we should
        // add that to the asset hash so it can be downloaded and added to the template item
        // and also cook some unique asset name so we can inject a placeholder
        return row.cards.reduce(convertToTemplatizedCard, { assets: [], cards: [] });
    }
    function convertToTemplatizedCard(acc, card) {
        var result = convertCard(card);
        acc.assets = acc.assets.concat(result.assets);
        acc.cards.push(result.card);
        return acc;
    }

    /**
     * Extract the fileSrc and cropSrc assets from settings.
     *
     * @param {ISettings} settings
     */
    function extractAssets(settings) {
        var assets = [];
        if (settings.fileSrc) {
            assets.push(settings.fileSrc);
        }
        if (settings.cropSrc) {
            assets.push(settings.cropSrc);
        }
        return assets;
    }

    /**
     * Convert a section, collecting assets along the way...
     * @param {ISection} section the section to templatize
     */
    function convertSection(section) {
        var _a;
        // if the section has a background image, and it has a url, we should
        // add that to the asset hash so it can be downloaded and added to the template item
        // and also cook some unique asset name so we can inject a placeholder
        var _b = section.rows.reduce(toTemplatizedRows, {
            assets: [],
            rows: []
        }), rows = _b.rows, assets = _b.assets;
        var result = {
            section: hubCommon.cloneObject(section),
            assets: assets
        };
        result.section.rows = rows;
        if (sectionHasBackgroundFile(section)) {
            (_a = result.assets).push.apply(_a, extractAssets(section.style.background));
        }
        return result;
    }
    function toTemplatizedRows(acc, row) {
        var _a;
        var _b = convertRow(row), assets = _b.assets, cards = _b.cards;
        (_a = acc.assets).push.apply(_a, assets);
        acc.rows.push({ cards: cards });
        return acc;
    }
    function sectionHasBackgroundFile(clonedSection) {
        return hubCommon.getProp(clonedSection, "style.background.fileSrc");
    }

    /**
     * Convert a layout to a templatized version of itself
     * @param {ILayout} layout the layout to templatize
     */
    function convertLayoutToTemplate(layout) {
        if (!layout) {
            return null;
        }
        // walk the sections, rows, cards... then call to fn's to convert specific cards...
        var converted = layout.sections.reduce(function (acc, section) {
            var _result = convertSection(section);
            acc.assets = acc.assets.concat(_result.assets);
            acc.sections.push(_result.section);
            return acc;
        }, { assets: [], sections: [] });
        // assemble the response
        var result = {
            assets: converted.assets,
            layout: {
                sections: converted.sections
            }
        };
        if (layout.header) {
            result.layout.header = hubCommon.cloneObject(layout.header);
        }
        if (layout.footer) {
            result.layout.footer = hubCommon.cloneObject(layout.footer);
        }
        return result;
    }

    /**
     * THIS UTIL IS NO LONGER IN USE BUT MAY BE IN THE FUTURE - TATE
     */
    /**
     * Removes any image "crop" versions that are no longer
     * used in the site layout.
     * TODO: Move to a module that is shared with Pages and then
     * also wire into the Page update cycle.
     * @param {String} id Id of the site or page item
     * @param {Object} layout Layout
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function removeUnusedResources(id, layout, hubRequestOptions) {
        var layoutImageCropIds = _getImageCropIdsFromLayout(layout);
        return getItemResources(id, hubRequestOptions).then(function (response) {
            var itemResourcesOnAGO = (response.resources || []).map(extractResourceProperty);
            var imageItemResourcesOnAGO = itemResourcesOnAGO.filter(resourceStartsWithImageSource);
            // getItemResources mutates the options, adding a params hash
            delete hubRequestOptions.params;
            var itemResourcesToRemove = getUnusedItemCrops(layoutImageCropIds, imageItemResourcesOnAGO);
            return removeUnusedResourcesFromAGO(id, itemResourcesToRemove, hubRequestOptions.authentication);
        });
    }
    function extractResourceProperty(entry) {
        return entry.resource;
    }
    function getUnusedItemCrops(layoutImageCropIds, itemImageResources) {
        if (!layoutContainsImageCards(layoutImageCropIds)) {
            // if there aren't any image cards in saved layout, delete all crops
            return itemImageResources;
        }
        // otherwise find crops for image cards that do not contain a current cropId
        return itemImageResources.filter(isNotACurrentImageCropId(layoutImageCropIds));
    }
    function layoutContainsImageCards(layoutImageCropIds) {
        return layoutImageCropIds.length > 0;
    }
    function resourceStartsWithImageSource(agoResource) {
        return agoResource.indexOf("hub-image-card-crop-") === 0;
    }
    function isNotACurrentImageCropId(imageCropIds) {
        var cropRegex = new RegExp("-crop-(" + imageCropIds.join("|") + ").png$");
        return function (resource) { return !resource.match(cropRegex); };
    }
    function removeUnusedResourcesFromAGO(id, unusedCrops, authentication) {
        // failSafe these calls b/c this is not critical
        var failSaveRemoveItemResources = hubCommon.failSafe(removeItemResource, {
            success: true
        });
        return Promise.all(unusedCrops.map(function (resource) {
            return failSaveRemoveItemResources({
                id: id,
                resource: resource,
                authentication: authentication
            });
        }));
    }

    /**
     * Return a list of items this site depends on
     */
    function getSiteDependencies(model) {
        var pages = hubCommon.getProp(model, "data.values.pages") || [];
        var pageIds = pages.map(function (p) { return p.id; });
        var layout = hubCommon.getProp(model, "data.values.layout") || {};
        var layoutDepIds = getLayoutDependencies(layout);
        return layoutDepIds.concat(pageIds);
    }

    var DRAFT_RESOURCE_REGEX = /^draft-(\d+).json$/;

    /**
     * Given a Page Model, return a template object
     * @param {Object} model The Page item model to convert into a template
     * @param {IHubRequestOptions} hubRequestOptions IRequestOptions object, with isPortal, and portalSelf
     */
    function convertPageToTemplate(model, hubRequestOptions) {
        var tmpl = hubCommon.cloneObject(model);
        // set things we always want...
        tmpl.type = getPageItemType(hubRequestOptions.isPortal);
        tmpl.key = hubCommon.propifyString(model.item.title) + "_" + hubCommon.createId("i");
        tmpl.itemId = model.item.id;
        // now pass the item off to be normalized
        tmpl.item = hubCommon.normalizeSolutionTemplateItem(tmpl.item);
        tmpl.data.values.sites = [];
        ["source", "updatedAt", "updatedBy", "folderId", "slug"].forEach(function (p) {
            delete tmpl.data.values[p];
        });
        // convert the layout...
        var layoutConversion = convertLayoutToTemplate(tmpl.data.values.layout);
        // the conversion can return an array of assets to convert, but for now, we are not using that...
        tmpl.data.values.layout = layoutConversion.layout;
        tmpl.dependencies = getSiteDependencies(model);
        // convert any internal references in /data to the item's id into `{{appId}}`
        tmpl.data = hubCommon.replaceItemId(tmpl.data, tmpl.itemId);
        if (!tmpl.item.properties) {
            tmpl.item.properties = {};
        }
        return hubCommon.getItemAssets(model.item, hubRequestOptions).then(function (assets) {
            // Because we don't want to include the draft resource when clone a page
            // we are filtering out assets that are not 'draft-{timestamp}.json'
            tmpl.assets = assets.filter(function (asset) { return asset.name.search(DRAFT_RESOURCE_REGEX) === -1; });
            return tmpl;
        });
    }

    /**
     * Given a template, settings and transformation hashes, construct the new Page model.
     * Altough this is async, it does not persist the page
     * @param {Object} template Json Template of the Page
     * @param {Object} settings Hash of values to use in the interpolation
     * @param {Object} transforms Hash of transrormation functions available during interpolation
     * @param {IHubRequestOptions} requestOptions
     */
    function createPageModelFromTemplate(template, settings, transforms, hubRequestOptions) {
        // add url to the assets, ref'ing the original location
        template.assets = hubCommon.addSolutionResourceUrlToAssets(template, hubRequestOptions);
        // request options is not currently used, but it *may* be needed, and this fn is part
        //  of an interface needed for Solution Generation and SOME item type will need
        // to make xhrs in this process
        var pageModel = hubCommon.interpolate(template, settings, transforms);
        if (!pageModel.item.properties) {
            pageModel.item.properties = {};
        }
        // Debatable if this should be in the template, but since it's
        // an important part of the relationship system we manually assign it
        var parentInitiativeId = hubCommon.getProp(settings, "initiative.id");
        if (parentInitiativeId) {
            hubCommon.deepSet(pageModel, "item.properties.parentInitiativeId", parentInitiativeId);
        }
        // put the slug into the hash so we can use it in following templates
        hubCommon.deepSet(pageModel, "data.values.slug", hubCommon.slugify(pageModel.item.title));
        // do any other work here...
        return Promise.resolve(pageModel);
    }

    /**
     * To account for complexities in the Solution generation process
     * we need to ensure that the site is linked to the Page before
     * we throw this all through the unlink/delete process
     * @param {Object} siteModel Site Model
     * @param {Objet} pageModel Page Model
     */
    function ensurePageHasSiteEntry(siteModel, pageModel) {
        var siteId = siteModel.item.id;
        var parentInitiativeId = hubCommon.getProp(siteModel, "item.properties.parentInitiativeId");
        // swap initiativeId to siteId
        // for a period of time, this happened during Solution generation
        if (parentInitiativeId) {
            var currentSites = hubCommon.getProp(pageModel, "data.values.sites");
            var initiativeEntry = currentSites.find(function (e) {
                return e.id === parentInitiativeId;
            });
            if (initiativeEntry) {
                initiativeEntry.id = siteId;
            }
        }
        // ensure that we have an entry for the site
        // during solution generation, we can't inject the
        // site id into the page because the page is created
        // before the site item. We need this present so that
        // the unlinkSiteFromPage functions will be able to update
        // the upstream site
        var sites = hubCommon.getProp(pageModel, "data.values.sites");
        var siteEntry = sites.find(function (e) {
            return e.id === siteId;
        });
        if (!siteEntry) {
            pageModel.data.values.sites.push({
                id: siteId,
                title: "Current Site to ensure clean removal"
            });
        }
        return pageModel;
    }

    /**
     * Determines whether an item is a page item or not
     * @param item - the item
     */
    function isPage(item) {
        return hubCommon.normalizeItemType(item) === "Hub Page";
    }

    /**
     * Returns the right include list for the item type.
     * @param siteOrPageModel - the site or page model
     * @private
     */
    function _includeListFromItemType(siteOrPageItem) {
        var includeList;
        if (isSite(siteOrPageItem)) {
            includeList = SITE_DRAFT_INCLUDE_LIST;
        }
        else if (isPage(siteOrPageItem)) {
            includeList = PAGE_DRAFT_INCLUDE_LIST;
        }
        else {
            throw TypeError("@esri/hub-sites: drafts only belong to a site or a page item model");
        }
        return includeList;
    }

    /**
     * Returns true if site or page model has unpublished changes
     * @param siteOrPageModel
     */
    function hasUnpublishedChanges(siteOrPageModel) {
        return hubCommon.includes(siteOrPageModel.item.typeKeywords, UNPUBLISHED_CHANGES_KW);
    }

    /**
     * Returns a copy of the model marked as having unpublished changes
     * @param {*} siteOrPageModel
     * @param {*} hubRequestOptions
     */
    function markPublished(siteOrPageModel) {
        var model = hubCommon.cloneObject(siteOrPageModel);
        model.item.typeKeywords = model.item.typeKeywords.filter(function (kw) { return kw !== UNPUBLISHED_CHANGES_KW; });
        return model;
    }

    /**
     * Returns a copy of the model marked as having unpublished changes
     * @param {*} siteOrPageModel
     * @param {*} hubRequestOptions
     */
    function markUnpublished(siteOrPageModel) {
        var model = hubCommon.cloneObject(siteOrPageModel);
        if (!hubCommon.includes(model.item.typeKeywords, UNPUBLISHED_CHANGES_KW)) {
            model.item.typeKeywords.push(UNPUBLISHED_CHANGES_KW);
        }
        return model;
    }

    var SITE_UI_VERSION = "2.4";

    /**
     * Return the Portal subdomain typekeyword
     * @param {string} subdomain Portal Subdomain
     * @private
     */
    function _getPortalDomainTypeKeyword(subdomain) {
        return ("hubsubdomain|" + subdomain).toLowerCase();
    }

    /**
     * Ensure that an entry for the specified subdomain exists in the
     * typeKeyword array. Will also remove any other domain entries,
     * @param {String} subdomain Subdomain name
     * @param {Array} typeKeywords Array of typekeywords
     * @private
     */
    function _ensurePortalDomainKeyword(subdomain, typeKeywords) {
        if (typeKeywords === void 0) { typeKeywords = []; }
        // if the current entry is in the keywords array, just return it
        var expectedKeyword = _getPortalDomainTypeKeyword(subdomain);
        if (hubCommon.includes(typeKeywords, expectedKeyword)) {
            return typeKeywords;
        }
        else {
            return typeKeywords.reduce(function (acc, kw) {
                if (!/^hubsubdomain/.test(kw)) {
                    acc.push(kw);
                }
                return acc;
            }, [expectedKeyword]);
        }
    }

    /**
     * Update an existing site item
     * This function supports the equivalent of a PATCH REST operation
     * It will fetch the current item from ago, and then apply
     * a subset of property changes to the model if a allowList is included.
     * The allowList can include any property paths on the item.
     * If the list is empty, then the entire site model is overwritten.
     * @param {Object} model Site Model to update
     * @param {IUpdateSiteOptions} updateSiteOptions
     */
    function updateSite(model, updateSiteOptions) {
        var allowList = updateSiteOptions.allowList || [];
        var _a = updateSiteOptions.updateVersions, updateVersions = _a === void 0 ? true : _a;
        // apply any on-save site upgrades here...
        hubCommon.deepSet(model, "data.values.uiVersion", SITE_UI_VERSION);
        hubCommon.deepSet(model, "data.values.updatedAt", new Date().toISOString());
        hubCommon.deepSet(model, "data.values.updatedBy", updateSiteOptions.authentication.username);
        // we only add these in if an allowList was passed in
        if (allowList.length) {
            allowList.push("data.values.updatedAt");
            allowList.push("data.values.updatedBy");
            if (updateVersions) {
                allowList.push("data.values.uiVersion");
                // any save needs to be able to update the schema version
                // which will have been bumped if a schema migration
                // occured during the load cycle
                allowList.push("item.properties.schemaVersion");
            }
        }
        // PORTAL-ENV: no domain service so we encode the subdomain in a typeKeyword
        if (updateSiteOptions.isPortal) {
            model.item.typeKeywords = _ensurePortalDomainKeyword(hubCommon.getProp(model, "data.values.subdomain"), model.item.typeKeywords);
            // see above comment why ths is gated...
            if (allowList.length) {
                allowList.push("item.typeKeywords");
            }
        }
        // Actually start the update process...
        var agoModelPromise;
        // if we have a allowList, refetch the site to check for changes...
        if (allowList.length) {
            agoModelPromise = hubCommon.getSiteById(model.item.id, updateSiteOptions);
        }
        else {
            // if we dont have a allowList, just resolve with the model we have
            agoModelPromise = Promise.resolve(model);
        }
        // Kick things off...
        return agoModelPromise
            .then(function (agoModel) {
            if (allowList.length) {
                // merge the props in the allow list into the model from AGO
                model = hubCommon.mergeObjects(model, agoModel, allowList);
            }
            // send the update to ago
            return updateItem({
                item: hubCommon.serializeModel(model),
                authentication: updateSiteOptions.authentication,
                params: { clearEmptyFields: true },
            });
        })
            .catch(function (err) {
            throw Error("updateSite: Error updating site: " + err);
        });
    }

    /**
     * Saves the published status of a site or page model
     * leaving everything else on the model alone.
     *
     * @param siteOrPageModel
     * @param requestOptions
     */
    function savePublishedStatus(siteOrPageModel, requestOptions) {
        var allowList = ["item.typeKeywords"]; // only want to save typeKeywords
        var item = siteOrPageModel.item;
        var prms;
        if (isSite(item)) {
            // when saving a draft site, we need to prevent the schemaVersion
            // from being updated. otherwise, if the user does not publish the draft,
            // functionality potentially will be broken for all users because the item
            // reflects the most recent schemaVersion without any of the actual schema
            // changes
            var isUnpublished = hasUnpublishedChanges(siteOrPageModel);
            prms = updateSite(siteOrPageModel, __assign(__assign({}, requestOptions), { allowList: allowList, updateVersions: !isUnpublished }));
        }
        else if (isPage(item)) {
            prms = updatePage(siteOrPageModel, __assign(__assign({}, requestOptions), { allowList: allowList }));
        }
        else {
            throw TypeError("@esri/hub-sites: only page or site models have a published state");
        }
        return prms;
    }

    /**
     * Gets the name of the resource for the current draft.
     * NOTE: There _should_ only be one, but sometimes it gets messed up.
     * @param siteOrPageId
     * @param hubRequestOptions
     * @private
     */
    function _getDraftResourceNames(siteOrPageId, hubRequestOptions) {
        return getItemResources(siteOrPageId, {
            portal: hubRequestOptions.portal,
            authentication: hubRequestOptions.authentication
        }).then(function (response) {
            // search through the resources to find the draft
            var draftResourceNames = response.resources
                .map(function (_a) {
                var name = _a.resource;
                return name;
            })
                .filter(function (name) { return name.search(DRAFT_RESOURCE_REGEX) !== -1; });
            return draftResourceNames;
        });
    }

    /**
     * Given an item id, removes the current draft resource if exists
     * @param {*} siteOrPageId
     * @param {*} hubRequestOptions
     */
    function deleteDraft(siteOrPageModel, hubRequestOptions) {
        var _a = siteOrPageModel.item, id = _a.id, owner = _a.owner;
        return _getDraftResourceNames(id, hubRequestOptions).then(function (draftResourceNames) {
            return Promise.all(draftResourceNames.map(function (resourceName) {
                return removeItemResource({
                    id: id,
                    owner: owner,
                    resource: resourceName,
                    portal: hubRequestOptions.portal,
                    authentication: hubRequestOptions.authentication
                });
            }));
        });
    }

    /**
     * Given a site or page model, saves a draft
     *
     * NOTE - replaces current draft if exists
     * @param {*} siteOrPageModel
     * @param {*} hubRequestOptions
     */
    function saveDraft(siteOrPageModel, hubRequestOptions) {
        var includeList = _includeListFromItemType(siteOrPageModel.item);
        var draft = hubCommon.buildDraft(siteOrPageModel, includeList);
        var draftBlob = hubCommon.objectToJsonBlob(draft);
        var draftName = "draft-" + Date.now() + ".json";
        var itemId = hubCommon.getProp(siteOrPageModel, "item.id");
        return deleteDraft(siteOrPageModel, hubRequestOptions)
            .then(function (_) {
            return addItemResource({
                id: itemId,
                owner: hubCommon.getProp(siteOrPageModel, "item.owner"),
                resource: draftBlob,
                name: draftName,
                private: false,
                portal: hubRequestOptions.portal,
                authentication: hubRequestOptions.authentication,
            });
        })
            .then(function (_) { return draft; });
    }

    /**
     *
     * @param draftName
     */
    function getDraftDate(draftName) {
        var parsed = DRAFT_RESOURCE_REGEX.exec(draftName);
        var ret;
        try {
            ret = new Date(parseInt(parsed[1], 10));
        }
        catch (_a) {
            ret = null;
        }
        return ret;
    }

    /**
     * Gets the name of the most recent resource for the current draft.
     * NOTE: There _should_ only be one, but sometimes it gets messed up.
     * @param siteOrPageId
     * @param hubRequestOptions
     * @private
     */
    function _getMostRecentDraftName(siteOrPageId, hubRequestOptions) {
        return _getDraftResourceNames(siteOrPageId, hubRequestOptions).then(function (draftNames) {
            if (!draftNames.length)
                return null;
            var dates = draftNames.map(function (name) { return [name, getDraftDate(name)]; });
            dates.sort(function (_a, _b) {
                _a[0]; var dateA = _a[1];
                _b[0]; var dateB = _b[1];
                if (dateB > dateA) {
                    return 1;
                }
                else if (dateA > dateB) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            return dates[0][0];
        });
    }

    var schemaVersionPath = "item.properties.schemaVersion";
    var initialDraftVersion = 1.3;
    /**
     * Applies the schema upgrades
     * @param draft IDraft
     */
    function upgradeDraftSchema(draft) {
        if (hubCommon.getProp(draft, "item.properties.schemaVersion") === undefined) {
            hubCommon.deepSet(draft, schemaVersionPath, initialDraftVersion);
        }
        if (hubCommon.getProp(draft, "item.properties.schemaVersion") === hubCommon.SITE_SCHEMA_VERSION) {
            return draft;
        }
        else {
            var migrated = draft;
            // apply site schema upgrade functions in order...
            // don't have do do them all since drafts only got released
            // at version 1.3
            migrated = hubCommon._ensureTelemetry(draft);
            return migrated;
        }
    }

    function isSiteDraft(draft) {
        // Maybe a better way to do this, but can't use item type
        // because we have Web Mapping Application sites in the wild
        // and typeKeywords don't exist on drafts.
        //
        // We could always request the site item and check it as part of
        // this but I'd rather not since that's an extra XHR and this is a
        // pretty robust schema check.
        return (hubCommon.getProp(draft, "data.values.capabilities") !== undefined &&
            hubCommon.getProp(draft, "data.values.theme") !== undefined);
    }
    /**
     * Fetches the draft for a site or page if exists.
     * @param {*} siteOrPageId
     * @param {*} hubRequestOptions
     */
    function fetchDraft(siteOrPageId, hubRequestOptions) {
        return _getMostRecentDraftName(siteOrPageId, hubRequestOptions)
            .then(function (draftResourceName) {
            var ret = null;
            if (draftResourceName) {
                ret = getItemResource(siteOrPageId, {
                    fileName: draftResourceName,
                    readAs: "json",
                    authentication: hubRequestOptions.authentication,
                    portal: hubRequestOptions.portal
                });
            }
            return ret;
        })
            .then(function (draft) {
            if (draft && isSiteDraft(draft)) {
                draft = upgradeDraftSchema(draft);
            }
            return draft;
        });
    }

    /**
     * Applies a draft resource to an item model
     * @param {*} siteOrPageModel
     * @param {*} draft
     */
    function applyDraft(siteOrPageModel, draft) {
        if (!draft)
            return siteOrPageModel;
        var includeList = _includeListFromItemType(siteOrPageModel.item);
        return hubCommon.mergeObjects(draft, hubCommon.cloneObject(siteOrPageModel), includeList);
    }

    /**
     * This function fetches and applies the draft
     * to the site or page if the draft is available.
     *
     * It returns a completely new object with the draft applied
     * if there is one, otherwise it just returns the site or
     * page model argument.
     *
     * @param {*} siteOrPageModel
     * @param {*} hubRequestOptions
     */
    function fetchAndApplyDraft(siteOrPageModel, hubRequestOptions) {
        return fetchDraft(hubCommon.getProp(siteOrPageModel, "item.id"), hubRequestOptions).then(function (draft) { return applyDraft(siteOrPageModel, draft); });
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Get the domains associated with a Hub Site.
     * @param siteId - Identifier of the Hub Site
     * @param requestOptions - request options that may include authentication
     * @returns A Promise that will resolve with the domains associated with the site.
     */
    function getDomains(siteId, requestOptions) {
        var url = hubCommon._getDomainServiceUrl(hubCommon.getHubApiUrl(requestOptions));
        var options = __assign({ params: { siteId: siteId }, httpMethod: "GET" }, requestOptions);
        return request(url, options);
    }
    /**
     * Get the domain associated with a Hub Site. Since a site may have a
     * custom domain, in addition to a default domain, we will return the
     * custom domain over the default domain.
     *
     * @param siteId - Identifier of the Hub Site
     * @param requestOptions - request options that may include authentication
     * @returns A Promise that will resolve with the domains associated with the site.
     */
    function getDomain(siteId, requestOptions) {
        return getDomains(siteId, requestOptions).then(function (response) {
            if (response.length > 1) {
                // ok - in this case, it's likely that we have a default domain and a custom domain...
                // we want the one that's custom... i.e. does not contain arcgis.com
                var customEntry = response.reduce(function (acc, entry) {
                    if (!entry.hostname.includes("arcgis.com")) {
                        acc = entry;
                    }
                    return acc;
                }, null);
                if (customEntry) {
                    // return the custom domain
                    return customEntry.hostname;
                }
                else {
                    // just pick the first one
                    return response[0].hostname;
                }
            }
            else {
                // there is only 1, so return it
                return response[0].hostname;
            }
        });
    }

    /**
     * Remove the well-known team groups
     * Underlying calls are failsafe so this will never throw
     * but the groups may not be deleted
     * @param {Object} siteModel Site Model
     * @param {IRequestOptions} requestOptions
     * @private
     */
    function _removeSiteGroups(siteModel, requestOptions) {
        var teamsToDelete = [
            "collaborationGroupId",
            "contentGroupId",
            "followersGroupId"
        ].reduce(function (acc, prop) {
            return hubCommon.maybePush(hubCommon.getProp(siteModel, "item.properties." + prop), acc);
        }, []);
        var promises = teamsToDelete.map(function (id) {
            var opts = Object.assign({ id: id }, requestOptions);
            return hubCommon._unprotectAndRemoveGroup(opts);
        });
        return Promise.all(promises);
    }

    /**
     * Remove the parent initiative item, if it exists
     * Failsafe
     * @param {Object} siteModel Site Model
     * @param {IRequestOptions} requestOptions
     * @private
     */
    function _removeParentInitiative(siteModel, requestOptions) {
        var parentInitiativeId = hubCommon.getProp(siteModel, "item.properties.parentInitiativeId");
        if (parentInitiativeId) {
            var opts = Object.assign({ id: parentInitiativeId, owner: siteModel.item.owner }, requestOptions);
            return hubCommon._unprotectAndRemoveItem(opts);
        }
        else {
            return Promise.resolve();
        }
    }

    /**
     * Remove a Site from the Hub Index system
     * @param {Object} siteModel Site Model
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _removeSiteFromIndex(siteModel, hubRequestOptions) {
        if (hubRequestOptions.isPortal) {
            return Promise.resolve();
        }
        else {
            var url = hubCommon.getHubApiUrl(hubRequestOptions) + "/api/v3/" + siteModel.item.id;
            var opts = {
                method: "DELETE",
                mode: "cors",
                headers: {
                    Authorization: hubRequestOptions.authentication.token,
                },
            };
            return fetch(url, opts)
                .then(function (raw) { return raw.json(); })
                .then(function (_) {
                // TODO: Should we do anything here?
                return { success: true };
            })
                .catch(function (err) {
                throw Error("_removeSiteFromIndex: Error removing site from index: " + err);
            });
        }
    }

    /**
     * Remove the domain entries for a site
     * @param {string} siteId Item Id of the site to remove the domain entries for
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _removeSiteDomains(siteId, hubRequestOptions) {
        if (hubRequestOptions.isPortal) {
            return Promise.resolve([]);
        }
        return hubCommon.removeDomainsBySiteId(siteId, hubRequestOptions).then(function (response) { return response; });
    }

    /**
     * We have updated aspects of the site templating logic, and now we need to
     * ensure that the groupId properties in the item template have :optional
     * if they are defined. This function simply does that.
     * @param {Object} itemTemplate template for the item part of the site
     * @private
     */
    function _ensureOptionalGroupsTemplating(itemTemplate) {
        var props = ["collaborationGroupId", "contentGroupId", "followersGroupId"];
        var tmpl = hubCommon.cloneObject(itemTemplate);
        props.forEach(function (prop) {
            var val = hubCommon.getProp(tmpl, "properties." + prop);
            if (val) {
                if (val.match(/^\{\{.*\}\}$/)) {
                    if (!val.match(/:optional\}\}$/g)) {
                        // replace it
                        tmpl.properties[prop] = val.replace("}}", ":optional}}");
                    }
                }
                else {
                    delete tmpl.properties[prop];
                }
            }
        });
        return tmpl;
    }

    /**
     * The item type depends if the app is running
     * in ArcGIS Enterprise vs AGO
     * @param {boolean} isPortal Is this running in Enterprise?
     */
    function getSiteItemType(isPortal) {
        var type = "Hub Site Application";
        if (isPortal) {
            type = "Site Application";
        }
        return type;
    }

    /**
     * Enture that the site model has the correct type and tags
     * Mutates the Model
     * @param {Object} model Site Model
     * @param {Object} currentUser Current User
     * @param {Boolean} isPortal Is this running in ArcGIS Enterprise
     * @private
     */
    function _ensureTypeAndTags(model, isPortal) {
        model = hubCommon.cloneObject(model);
        model.item.type = getSiteItemType(isPortal);
        // ensure typekeywords array
        if (!Array.isArray(model.item.typeKeywords)) {
            model.item.typeKeywords = [];
        }
        if (!hubCommon.includes(model.item.typeKeywords, "hubSite")) {
            model.item.typeKeywords.push("hubSite");
        }
        return model;
    }

    /* istanbul ignore next */
    /**
     * Given a Site Model, add the required domains.
     * This should only be called as part of the `createSite` flow
     * @param {Object} model site model
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _addSiteDomains(model, hubRequestOptions) {
        // eslint-disable-next-line no-console
        console.warn("@esri/hub-sites::_addSiteDomains is deprecated. Please use @esri/hub-common::addSiteDomains instead");
        return hubCommon.addSiteDomains(model, hubRequestOptions);
    }

    /**
     * Get the correct url used to edit the site
     * @param item the site item
     */
    function getSiteEditUrl(item) {
        return item.url + "/edit";
    }

    /**
     * Update the redirect uri's that are valid for an existing app that's registered
     * for oAuth.
     * @param {string} clientId Client Id of the existing app to be updated
     * @param {Array} redirectUris Array of valid redirect uris for the app
     * @param {IRequestOptions} requestOptions
     */
    function updateAppRedirectUris(clientId, redirectUris, requestOptions) {
        var url = hubCommon.getPortalApiUrl(requestOptions) + "/oauth2/apps/" + clientId + "/update";
        var options = {
            method: "POST",
            authentication: requestOptions.authentication,
            params: {
                client_id: clientId,
                redirect_uris: JSON.stringify(redirectUris)
            }
        };
        return request(url, options);
    }

    /**
     * Update the list of valid uris associated with the Site item
     * @param {Object} site Site Model
     * @param {Array} uris Array of valid uris for the site
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function updateSiteApplicationUris(site, uris, hubRequestOptions) {
        if (hubRequestOptions.isPortal)
            return Promise.resolve({});
        // get http and https versions of all uris
        var redirectUris = uris.reduce(function (acc, uri) {
            return acc.concat(hubCommon._getHttpAndHttpsUris(uri));
        }, []);
        // update the redirect uris for the application
        return updateAppRedirectUris(site.data.values.clientId, redirectUris, hubRequestOptions)
            .then(function () {
            // now we update the domains, removing any that are no longer used
            return hubCommon.getDomainsForSite(site.item.id, hubRequestOptions);
        })
            .then(function (domainInfos) {
            // get all domains that are no longer associated with the site
            var domainsToRemove = domainInfos.filter(function (domain) { return !hubCommon.includes(uris, domain.hostname); });
            // get all new domains that are now associated with the site
            var hostnames = domainInfos.map(function (domain) { return domain.hostname; });
            var domainsToAdd = uris.filter(function (uri) { return !hubCommon.includes(hostnames, uri); });
            // finally, kick all the promises
            var domainPromises = [];
            domainsToRemove.forEach(function (domain) {
                return domainPromises.push(hubCommon.removeDomain(domain.id, hubRequestOptions));
            });
            domainsToAdd.forEach(function (uri) {
                return domainPromises.push(hubCommon.addDomain({
                    orgKey: hubRequestOptions.portalSelf.urlKey,
                    orgId: hubRequestOptions.portalSelf.id,
                    orgTitle: hubRequestOptions.portalSelf.name,
                    hostname: uri,
                    siteId: site.item.id,
                    siteTitle: site.item.title,
                    clientKey: site.data.values.clientId,
                    sslOnly: domainInfos[0] ? !!domainInfos[0].sslOnly : true,
                }, hubRequestOptions));
            });
            return Promise.all(domainPromises);
        });
    }

    /* istanbul ignore next */
    /**
     * Register the Site item as an application so we can oauth against it
     * @param {string} siteId Item Id of the site
     * @param {Array} uris Arrayf valid uris for the site
     * @param {IHubRequestOptions} hubRequestOptions
     */
    /* istanbul ignore next */
    function registerSiteAsApplication(model, hubRequestOptions) {
        // tslint:disable-next-line
        console.warn("@esri/hub-sites::registerSiteAsApplication is deprecated. Please use @esri/hub-common::registerSiteAsApplication instead");
        return hubCommon.registerSiteAsApplication(model, hubRequestOptions);
    }

    /**
     * Register an Item as an application, enabling oAuth flows at custom
     * domains. Only item types with "Application" in the name are valid
     * with this API call.
     * @param {string} itemId Item Id of item to create an application for
     * @param {Array} redirectUris Array of valid redirect uris for the app
     * @param {string} appType Defaults to "browser"
     * @param {IRequestOptions} requestOptions
     */
    /* istanbul ignore next */
    function registerBrowserApp(itemId, redirectUris, requestOptions) {
        // tslint:disable-next-line
        console.warn("@esri/hub-sites::registerBrowserApp is deprecated. Please use @esri/hub-common::registerBrowserApp instead");
        return hubCommon.registerBrowserApp(itemId, redirectUris, requestOptions);
    }

    /**
     * Given a site, update all the linked page items and remove their
     * references to the site
     * @param {Object} siteModel Site Model
     * @param {IRequestOptions} requestOptions
     */
    function unlinkPagesFromSite(siteModel, requestOptions) {
        var linkedPages = hubCommon.mapBy("id", hubCommon.getWithDefault(siteModel, "data.values.pages", []));
        // we need to unlink the site from all it's pages. However, these calls *could* fail
        // if the current user lacks rights to save the site/page item, so we just make sure these
        // always resolve. In the Ember service code, we used `allSettled` but that's RSVP special sauce
        var failSafeUnlink = hubCommon.failSafe(unlinkSiteAndPage);
        return Promise.all(linkedPages.map(function (pageId) {
            var opts = Object.assign({
                siteModel: siteModel,
                pageId: pageId
            }, requestOptions);
            return failSafeUnlink(opts);
        }));
    }

    /**
     * Ensure that the item template has `:optional` on the item.properties.* team
     * properties. Does not mutate the passed in object - returns a clone.
     * @param {Object} itemTemplate Item Template to work with
     */
    function ensureOptionalGroupsTemplating(itemTemplate) {
        var props = ["collaborationGroupId", "contentGroupId", "followersGroupId"];
        var tmpl = hubCommon.cloneObject(itemTemplate);
        props.forEach(function (prop) {
            var val = hubCommon.getProp(tmpl, "properties." + prop);
            if (val) {
                if (val.match(/^\{\{.*\}\}$/)) {
                    if (!val.match(/:optional\}\}$/g)) {
                        // replace it
                        tmpl.properties[prop] = val.replace("}}", ":optional}}");
                    }
                }
                else {
                    delete tmpl.properties[prop];
                }
            }
        });
        return tmpl;
    }

    /**
     * Remove a Site Item
     * * Unlinks all pages
     * * removes all groups
     * * deletes any parent initiatve
     * * removes site from hub index,
     * * removes all domains associated with the site
     * * removes the site item
     *
     * @param {string || Object} idOrModel Id of the site or a site model
     * @param {IHubUserRequestOptions} hubRequestOptions
     */
    function removeSite(idOrModel, hubRequestOptions) {
        var modelPromise;
        if (typeof idOrModel === "string") {
            modelPromise = hubCommon.getModel(idOrModel, hubRequestOptions);
        }
        else {
            modelPromise = Promise.resolve(idOrModel);
        }
        var siteModel;
        return modelPromise
            .then(function (model) {
            siteModel = model;
            return unlinkPagesFromSite(siteModel, hubRequestOptions);
        })
            .then(function () {
            var opts = Object.assign({ id: siteModel.item.id, owner: siteModel.item.owner }, hubRequestOptions);
            return hubCommon._unprotectAndRemoveItem(opts);
        })
            .then(function () {
            // remove the groups
            return _removeSiteGroups(siteModel, hubRequestOptions);
        })
            .then(function () {
            // remove the parent initiative if that's a thing
            return _removeParentInitiative(siteModel, hubRequestOptions);
        })
            .then(function () {
            // remove the domains associated with the site item
            return _removeSiteDomains(siteModel.item.id, hubRequestOptions);
        })
            .then(function () {
            // remove the site from the Hub index
            // failSafe because this is not critical
            return hubCommon.failSafe(_removeSiteFromIndex, { success: true })(siteModel, hubRequestOptions);
        })
            .catch(function (err) {
            throw Error("removeSite: Error removing site: " + err);
        });
    }

    /**
     * Enture that the site model has all the required properties
     * and force them to be bumped to all the current values.
     * Returns a clone of the model
     * @param {Object} model Site Model
     * @param {Object} currentUser Current User
     * @param {Boolean} isPortal Is this running in ArcGIS Enterprise
     */
    function ensureRequiredSiteProperties(model, username, isPortal) {
        if (isPortal === void 0) { isPortal = false; }
        model = hubCommon.cloneObject(model);
        model.item.owner = username;
        model.item.access = "private";
        // ensure typekeywords array
        if (!Array.isArray(model.item.typeKeywords)) {
            model.item.typeKeywords = [];
        }
        model.data.values.updatedAt = new Date().toISOString();
        model.data.values.updatedBy = username;
        if (isPortal) {
            model.item.typeKeywords.push(_getPortalDomainTypeKeyword(model.data.values.subdomain));
        }
        // Handle item url - if it's set...
        if (!model.item.url) {
            var hostname = hubCommon.getProp(model, "data.values.customHostname") ||
                hubCommon.getProp(model, "data.values.defaultHostname");
            // unless a custom hostname was passed in AND the site item's url is falsey
            // (which currently should be impossible) we want the protocol of the item url
            // to be https.
            var protocol = "https";
            if (model.data.values.customHostname) {
                protocol = "http";
            }
            model.item.url = protocol + "://" + hostname;
        }
        // Ensure pages is an array...
        if (!Array.isArray(hubCommon.getProp(model, "data.values.pages"))) {
            hubCommon.deepSet(model, "data.values.pages", []);
        }
        hubCommon.deepSet(model, "data.values.uiVersion", SITE_UI_VERSION);
        // ensure the type and tags...
        model = _ensureTypeAndTags(model, isPortal);
        // ensure the capabilities...
        var caps = [
            "api_explorer",
            "pages",
            "my_data",
            "social_logins",
            "json_chart_card",
            "document_iframes",
            "items_view",
            "app_page",
            "underlinedLinks",
            "globalNav",
        ];
        if (!isPortal) {
            caps.push("socialSharing");
        }
        hubCommon.deepSet(model, "data.values.capabilities", caps);
        // return the clone
        return model;
    }

    /**
     * Create a New Site
     * Creates and protects the site item
     * Uploads any assets/thumbnails passed in via options.assets array
     * If not portal..,
     * - register the site as an application, w/ needed redirect uris
     * - register the domains with the Hub Domain Service
     * @param {Object} model Site Model to create
     * @param {Object} options options hash. Key prop is assets
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function createSite(model, options, hubRequestOptions) {
        // ensure properties
        model = ensureRequiredSiteProperties(model, hubRequestOptions.authentication.username, hubRequestOptions.isPortal);
        // create the item
        return createItem({
            item: hubCommon.serializeModel(model),
            owner: model.item.owner,
            authentication: hubRequestOptions.authentication,
        })
            .then(function (createResponse) {
            // hold onto the Id so we can return a complete model
            model.item.id = createResponse.id;
            // protect it
            return protectItem({
                id: model.item.id,
                owner: model.item.owner,
                authentication: hubRequestOptions.authentication,
            });
        })
            .then(function (protectResponse) {
            // do app registration
            return hubCommon.registerSiteAsApplication(model, hubRequestOptions);
        })
            .then(function (appRegistrationResponse) {
            // store the clientId
            model.data.values.clientId = appRegistrationResponse.client_id;
            // If we have a dcat section, hoist it out as it may contain complex adlib
            // templates that are needed at run-time
            // If we have data.values.dcatConfig, yank it off b/c that may have adlib template stuff in it
            var dcatConfig = hubCommon.cloneObject(model.data.values.dcatConfig);
            delete model.data.values.dcatConfig;
            // with the id of the actual item
            model = hubCommon.interpolateItemId(model);
            // re-attach if we got anything...
            if (dcatConfig) {
                model.data.values.dcatConfig = dcatConfig;
            }
            return updateItem({
                item: hubCommon.serializeModel(model),
                authentication: hubRequestOptions.authentication,
            });
        })
            .then(function (updateResponse) {
            // Handle domains
            return hubCommon.addSiteDomains(model, hubRequestOptions);
        })
            .then(function (domainResponses) {
            // upload resources from url
            return hubCommon.uploadResourcesFromUrl(model, options.assets || [], hubRequestOptions);
        })
            .then(function (uploadResponses) {
            // default to a success response
            var sharePrms = Promise.resolve({ success: true });
            // share it to the collab team if that got created
            var collabGroupId = hubCommon.getProp(model, "item.properties.collaborationGroupId");
            if (collabGroupId) {
                sharePrms = shareItemWithGroup({
                    id: model.item.id,
                    groupId: collabGroupId,
                    authentication: hubRequestOptions.authentication,
                    confirmItemControl: true,
                });
            }
            return sharePrms;
        })
            .then(function (resp) {
            // if we created an initiative, ensure we inject the site Id into it
            var initiativeItemId = hubCommon.getProp(model, "item.properties.parentInitiativeId");
            if (initiativeItemId) {
                // get the item and update it
                return hubInitiatives.updateInitiativeSiteId(initiativeItemId, model.item.id, hubRequestOptions);
            }
            else {
                return Promise.resolve(true);
            }
        })
            .then(function (resp) {
            return model;
        })
            .catch(function (err) {
            throw Error("site-utils::createSite - Error creating site " + JSON.stringify(err));
        });
    }

    /**
     * Return the correct route for the portal hosted site
     * @param {String} subdomain Subdomain for the site
     * @param {Object} portal Portal Self
     */
    function getPortalSiteHostname(subdomain, portal) {
        var port;
        if (portal.allSSL) {
            port = portal.httpsPort !== 443 ? ":" + portal.httpsPort : "";
        }
        else {
            port = portal.httpPort !== 80 ? ":" + portal.httpPort : "";
        }
        // portalHostname will include the /<adaptor>
        // i.e. `dev0016196.esri.com/portal`, but since we may need to inject a port
        // we split things apart, and then recombine
        var parts = portal.portalHostname.split("/");
        var host = parts[0];
        var adaptor = "/"; // if there is no /<adaptor> then / should be valid
        if (parts[1]) {
            adaptor = "/" + parts[1] + "/";
        }
        // construct the url
        return "" + host + port + adaptor + "apps/sites/#/" + subdomain;
        // Note: in *most* cases the result would be the same as the line below
        // but there are some scenarios where we need to do the construction
        // so we can't simply use portalHostname
        // return `${portal.portalHostname}/apps/sites/#/${subdomain}`
    }

    /**
     * Construct the site url for a Portal Site item
     * @param {String} subdomain Subdomain for the site
     * @param {Object} portal Portal Self
     */
    function getPortalSiteUrl(subdomain, portal) {
        var protocol = "http:";
        if (portal.allSSL) {
            protocol = "https:";
        }
        var siteRoute = getPortalSiteHostname(subdomain, portal);
        return protocol + "//" + siteRoute;
    }

    /* istanbul ignore next */
    /**
     * Return the default theme, extended with values from the Org's shared theme
     * @param {Object} portalSelf Org's Portal object
     */
    function getTheme(portalSelf) {
        // eslint-disable-next-line no-console
        console.warn("@esri/hub-sites::getTheme is deprecated. Please use @esri/hub-common::getOrgDefaultTheme instead");
        return hubCommon.getOrgDefaultTheme(portalSelf);
    }

    /**
     * Given a Site Template, locate the initiative template
     * then adlib it and create the initiative item
     * @param {object} siteTemplate Site Template
     * @param {object} settings adlib interpolation hash
     * @param {object} transforms adlib transforms hash
     * @param {IHubRequestOptions}} hubRequestOptions
     * @private
     */
    function _createSiteInitiative(siteTemplate, settings, transforms, hubRequestOptions) {
        var cache = {};
        return hubInitiatives.getInitiativeTemplate(siteTemplate, hubRequestOptions)
            .then(function (initiativeTemplate) {
            // set the url that will be in the site
            initiativeTemplate.item.url = settings.solution.url;
            initiativeTemplate.item.title = settings.solution.title;
            initiativeTemplate.item.owner = hubRequestOptions.authentication.username;
            initiativeTemplate.item.typeKeywords = hubCommon.without(initiativeTemplate.item.typeKeywords, "Hub Initiative Template");
            initiativeTemplate.item.type = "Hub Initiative";
            // set the teams...
            Object.assign(initiativeTemplate.item.properties, settings.teams);
            // adlib to pick up anything else...
            var initiativeModel = hubCommon.interpolate(initiativeTemplate, settings, transforms);
            // and save it
            return hubInitiatives.addInitiative(initiativeModel, hubRequestOptions);
        })
            .then(function (model) {
            // hold in cache
            cache.model = model;
            // default to a success response
            var sharePrms = Promise.resolve({ success: true });
            // share it to the collab team if that got created
            var collabGroupId = hubCommon.getProp(settings, "teams.collaborationGroupId");
            if (collabGroupId) {
                sharePrms = shareItemWithGroup({
                    id: model.item.id,
                    groupId: collabGroupId,
                    authentication: hubRequestOptions.authentication,
                    confirmItemControl: true
                });
            }
            return sharePrms;
        })
            .then(function (_) {
            return cache.model;
        })
            .catch(function (ex) {
            throw Error("site-utils::_createSiteInitiative Error " + ex);
        });
    }

    /**
     * Update the tags on the teams after the initiative is created
     * Specifically:
     * - add  `hubInitiativeFollowers|<initiaiveId> to the followers group
     * @param {object} initiativeModel Initiative Model
     * @param {object} teams hash of teams
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _updateTeamTags(initiativeModel, teams, hubRequestOptions) {
        var prms = Promise.resolve({ success: true });
        // we have a followers group
        // TODO: COVER THIS WITH TESTS (spying wasnt working)
        /* istanbul ignore if */
        if (hubCommon.getProp(teams, "props.followersGroupId")) {
            // get the followers group out of the teams.groups array
            var followersGroup = teams.groups.find(function (g) { return g.id === teams.props.followersGroupId; });
            // now we want to add a tag
            followersGroup.tags.push("hubInitiativeFollowers|" + initiativeModel.item.id);
            // now we want to fire off an update
            prms = updateGroup({
                group: followersGroup,
                authentication: hubRequestOptions.authentication
            });
        }
        return prms;
    }

    /**
     * Wrapper for @esri/hub-common's `interpolate()`
     *
     * Some properties on siteTemplate are nested adlib templates that
     * need to be interpolated at runtime, not template activation time.
     * As such, this wrapper ensures that adlib does not process those
     * properties.
     *
     * Currently ignored properties include:
     * - `data.values.dcatConfig` (legacy DCAT-US 1.1 config with index value paths)
     * - `data.feeds (Home to all feed configs with v3 api value paths)
     *
     * @param siteTemplate
     * @param settings
     * @param transforms
     */
    function interpolateSite(siteTemplate, settings, transforms) {
        var template = hubCommon.cloneObject(siteTemplate);
        // Save nested adlib templates
        var legacyDcatUS11Config = hubCommon.cloneObject(template.data.values.dcatConfig);
        var feedConfigs = hubCommon.cloneObject(template.data.feeds);
        // Remove nested adlib templates from the main template so they will not be processed
        delete template.data.values.dcatConfig;
        delete template.data.feeds;
        var siteModel = hubCommon.interpolate(template, settings, transforms);
        // Attach nested templates onto the interpolated site
        if (legacyDcatUS11Config) {
            siteModel.data.values.dcatConfig = legacyDcatUS11Config;
        }
        if (feedConfigs) {
            siteModel.data.feeds = feedConfigs;
        }
        return siteModel;
    }

    /**
     * Convert a Site Template into a Site Model
     * This will create Hub Teams and an Initiative, depending on licensing
     * and privs.
     *
     * The subdomain for the site will be constructed from the `settings.solution.title`
     * unless that contains unicode chars. In that case the initial subdomain will be `site`
     * and `ensureUniqueDomainName` will increment it as necessary (i.e. site-1, site-2 etc)
     *
     * This returns the Model that still needs to be saved!
     * @param {object} template Site Template
     * @param {object} settings Adlib interpolation hash
     * @param {object} transforms hash of transform functions
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function createSiteModelFromTemplate(template, settings, transforms, hubRequestOptions) {
        // add url to the assets, ref'ing the original location
        template.assets = hubCommon.addSolutionResourceUrlToAssets(template, hubRequestOptions);
        // We may have templates which lack .properties so let's ensure that exists
        if (!template.item.properties) {
            template.item.properties = {};
        }
        // Kill props we don't want to roll forward if they happen to exist in the template
        [
            "customHostname",
            "externalUrl",
            "contentGroupId",
            "followersGroupId",
            "collaborationGroupId",
            "parentInitiativeId",
        ].forEach(function (prop) {
            delete template.data.values[prop];
        });
        var product = hubCommon.getHubProduct(hubRequestOptions.portalSelf);
        var title = hubCommon.getProp(settings, "solution.title") || "New Site";
        // handle issue with titles that are just numbers
        if (typeof title === "number") {
            title = title.toString();
            hubCommon.deepSet(settings, "solution.title", title);
        }
        // We need to carry some state through the promise chains
        // so we initialize an object outside the chain
        var state = {};
        // TODO: Eventually we'd like Enums
        var teamsToCreate = ["core", "content", "followers"];
        return hubTeams.createHubTeams({
            title: title,
            types: teamsToCreate,
            hubRequestOptions: hubRequestOptions,
        })
            .then(function (teams) {
            // fold teams into the settings hash - used mainly for cards
            settings.teams = hubCommon.cloneObject(teams.props);
            state.teams = teams;
            // directly set the teams into the template item as this ensures
            // the team props are always set vs relying on adlib vars to exist
            Object.assign(template.item.properties, teams.props);
            if (hubCommon.getProp(teams, "props.contentGroupId")) {
                hubCommon.deepSet(template, "data.catalog.groups", [teams.props.contentGroupId]);
            }
            // sites need unique domains names
            // We derive this from the title, unless the title has unicode chars
            // in which case we use `site`, and the `ensureUniqueDomainName` function
            // will increment that as needed - i.e. `site-23`
            var domainTitle = title;
            if (hasUnicodeChars(domainTitle)) {
                domainTitle = "site";
            }
            return hubCommon.ensureUniqueDomainName(hubCommon.slugify(domainTitle), hubRequestOptions);
        })
            .then(function (uniqueSubdomain) {
            var portal = hubRequestOptions.portalSelf;
            // TODO: Revisit this if/when we do more site templates which we want to maintain their theme
            settings.solution.theme = getTheme(portal);
            // set site-specific settings properties...
            settings.solution.subdomain = uniqueSubdomain;
            // setup the url properties
            if (hubRequestOptions.isPortal) {
                settings.solution.defaultHostname = getPortalSiteHostname(uniqueSubdomain, portal);
                settings.solution.url = getPortalSiteUrl(uniqueSubdomain, portal);
            }
            else {
                var base = hubCommon.stripProtocol(hubCommon.getHubApiUrl(hubRequestOptions));
                settings.solution.defaultHostname = uniqueSubdomain + "-" + portal.urlKey + "." + base;
                settings.solution.url = "https://" + uniqueSubdomain + "-" + portal.urlKey + "." + base;
            }
            // create the initiative
            var handleInitiative = Promise.resolve(null);
            if (product !== "portal") {
                handleInitiative = _createSiteInitiative(template, settings, transforms, hubRequestOptions);
            }
            return handleInitiative;
        })
            .then(function (maybeInitiative) {
            // if we got an initiative back...
            var teamUpdatePromise = Promise.resolve(null);
            if (maybeInitiative) {
                // add to settings hash so it's available to the site
                // typically all that's used is initiative.item.id
                settings.initiative = maybeInitiative;
                // directly set the parentInitiativeId vs relying on adlib
                template.item.properties.parentInitiativeId = maybeInitiative.item.id;
                // check if we created a followers team because we need to add the initiativeId into a tag
                teamUpdatePromise = _updateTeamTags(maybeInitiative, state.teams, hubRequestOptions);
            }
            return teamUpdatePromise;
        })
            .then(function (_) {
            var siteModel = interpolateSite(template, settings, transforms);
            // Special logic for the site title
            // if the title is a string, containing only numbers, then the interpolation will set it as
            // a number, which causes some problems... in that case, we stomp it in as a string...
            if (typeof siteModel.item.title === "number") {
                siteModel.item.title = hubCommon.getProp(settings, "solution.title");
                siteModel.data.values.title = hubCommon.getProp(settings, "solution.title");
            }
            return siteModel;
        })
            .catch(function (ex) {
            throw Error("site-utils::createSiteModelFromTemplate Error " + ex);
        });
    }
    /**
     * From Stackoverflow
     * https://stackoverflow.com/questions/147824/how-to-find-whether-a-particular-string-has-unicode-characters-esp-double-byte
     * This is the highest performance solution, combining three approaches
     */
    var unicodeCharRegex = /[^\u0000-\u00ff]/;
    function hasUnicodeChars(value) {
        if (value.charCodeAt(0) > 255)
            return true;
        return unicodeCharRegex.test(value);
    }

    /**
     * Convert an existing site into the Solution template format
     * @param {Object} model Site Model
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function convertSiteToTemplate(model, hubRequestOptions) {
        // clone it...
        var tmpl = hubCommon.cloneObject(model);
        // Ensure some properties are set correctly
        tmpl.type = getSiteItemType(hubRequestOptions.isPortal);
        tmpl.key = hubCommon.propifyString(model.item.title) + "_" + hubCommon.createId("i");
        tmpl.itemId = model.item.id;
        // now pass the item off to be normalized
        tmpl.item = hubCommon.normalizeSolutionTemplateItem(tmpl.item);
        // remove the url as it will be set when it's created
        delete tmpl.item.url;
        // Note: We do not template in the various team groups
        // When a site is created from a template, those properties
        // will be injected as needed
        tmpl.item.properties = {
            schemaVersion: hubCommon.SITE_SCHEMA_VERSION,
            children: [],
        };
        // inject interpolation propertues where we need them
        tmpl.item.title = "{{solution.title}}";
        tmpl.data.values.subdomain = "{{solution.subdomain}}";
        tmpl.data.values.defaultHostname = "{{solution.defaultHostname}}";
        tmpl.data.values.title = "{{solution.title}}";
        tmpl.data.values.subdomain = "{{solution.subdomain}}";
        tmpl.data.values.defaultHostname = "{{solution.defaultHostname}}";
        delete tmpl.data.catalog;
        // teams are set explicitly vs being interpolated
        delete tmpl.data.values.collaborationGroupId;
        // some props need to be reset to empty strings
        ["updatedAt", "updatedBy", "clientId", "siteId"].forEach(function (p) {
            tmpl.data.values[p] = "";
        });
        // others we should just delete
        [
            "customHostname",
            "externalUrl",
            "contentGroupId",
            "followersGroupId",
            "groups",
        ].forEach(function (p) {
            delete tmpl.data.values[p];
        });
        // update the default extent...
        if (hubCommon.getProp(tmpl, "data.values.defaultExtent")) {
            tmpl.data.values.defaultExtent = "{{organization.defaultExtent}}";
        }
        if (hubCommon.getProp(tmpl, "data.values.map.basemaps.primary.extent")) {
            tmpl.data.values.map.basemaps.primary.extent =
                "{{organization.defaultExtent}}";
        }
        // convert the layout...
        var layoutConversion = convertLayoutToTemplate(tmpl.data.values.layout);
        tmpl.data.values.layout = layoutConversion.layout;
        // convert any internal references in /data to the item's id into `{{appId}}`
        tmpl.data = hubCommon.replaceItemId(tmpl.data, tmpl.itemId);
        tmpl.dependencies = getSiteDependencies(model);
        return hubCommon.getItemAssets(model.item, hubRequestOptions).then(function (assets) {
            // Because we don't want to include the draft resource when clone a site
            // we are filtering out assets that are not 'draft-{timestamp}.json'
            tmpl.assets = assets.filter(function (asset) { return asset.name.search(DRAFT_RESOURCE_REGEX) === -1; });
            return tmpl;
        });
    }

    /**
     * Fetch the data for a site item by Id.
     * No schema upgrades are applied.
     * @param {String} id Item Id of the site
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _getSiteDataById(id, hubRequestOptions) {
        // Note: this was migrated to ensure consistentcy but it should not be used
        return getItemData(id, hubRequestOptions).then(function (data) {
            if (data.values.groupId && !data.values.collaborationGroupId) {
                // some 2.0 sites were created with a groupId instead of a collaborationGroupId and then were migrated
                data.values.collaborationGroupId = data.values.groupId;
                delete data.values.groupId;
            }
            return data;
        });
    }

    /**
     * Return a hash of settings for the groups, including the itemControl flag
     * Both, one or neither of these groups may exist
     * @param {object} siteModel Site Model
     * @private
     */
    function _getSecondPassSharingOptions(siteModel) {
        return [
            { prop: "item.properties.contentGroupId", itemControl: false },
            { prop: "item.properties.collaborationGroupId", itemControl: true }
        ].reduce(function (acc, entry) {
            var groupId = hubCommon.getProp(siteModel, entry.prop);
            if (groupId) {
                acc.push({
                    id: groupId,
                    confirmItemControl: entry.itemControl
                });
            }
            return acc;
        }, []);
    }

    function _getIneligibleModelIds(siteModel, models, hubRequestOptions) {
        var fetchSurveyModels = function (model) {
            return hubCommon.getSurveyModels(model.item, hubRequestOptions).then(function (_a) {
                var form = _a.form, featureService = _a.featureService, fieldworker = _a.fieldworker, stakeholder = _a.stakeholder;
                return [form, featureService, fieldworker, stakeholder].filter(Boolean);
            });
        };
        var inEligibleModelCollectionPromises = models.reduce(function (acc, model) {
            return model.item.type === "Form" ? __spreadArrays(acc, [fetchSurveyModels(model)]) : acc;
        }, [Promise.resolve([siteModel])]);
        return Promise.all(inEligibleModelCollectionPromises).then(function (ineligibleModelCollections) {
            return ineligibleModelCollections.reduce(function (acc, ineligibleModelCollection) { return __spreadArrays(acc, ineligibleModelCollection); }, []);
        });
    }
    function _getSharingEligibleModels(siteModel, models, hubRequestOptions) {
        return _getIneligibleModelIds(siteModel, models, hubRequestOptions).then(function (ineligibleModels) {
            return models.reduce(function (acc, model) {
                return ineligibleModels.find(function (_a) {
                    var id = _a.item.id;
                    return model.item.id === id;
                })
                    ? acc
                    : __spreadArrays(acc, [model]);
            }, []);
        });
    }

    /**
     * Share all the other models to the Site's content and collaboration groups, if
     * those groups were created for the site (depends on user's privs)
     * **DEPRECATED: Use shareItemsToSiteGroups() instead**
     * @param {object} siteModel Site Model
     * @param {Array} solutionModels Array of all models created by the Solution
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _shareItemsToSiteGroups(siteModel, solutionModels, hubRequestOptions) {
        /* tslint:disable no-console */
        console.info("DEPRECATED: _shareItemsToSiteGroups will be removed at v10.0.0. Use shareItemsToSiteGroups instead.");
        return shareItemsToSiteGroups(siteModel, solutionModels, hubRequestOptions);
    }
    /**
     * Share all the other models to the Site's content and collaboration groups, if
     * those groups were created for the site (depends on user's privs)
     * @param {object} siteModel Site Model
     * @param {Array} solutionModels Array of all models created by the Solution
     * @param {IHubRequestOptions} hubRequestOptions
     * @exported
     */
    function shareItemsToSiteGroups(siteModel, solutionModels, hubRequestOptions) {
        // Create Fail-safe version of share b/c this is not critical
        var failSafeShare = hubCommon.failSafe(shareItemWithGroup, { success: true });
        var groupsToShareTo = _getSecondPassSharingOptions(siteModel);
        // share all items in the solution to the groups, excluding the the site, form
        // and any form feature services
        return _getSharingEligibleModels(siteModel, solutionModels, hubRequestOptions).then(function (eligibleModels) {
            return Promise.all(eligibleModels.reduce(function (acc, m) {
                var itemSharePromises = groupsToShareTo.map(function (g) {
                    var opts = {
                        id: m.item.id,
                        groupId: g.id,
                        confirmItemControl: g.confirmItemControl,
                        authentication: hubRequestOptions.authentication,
                    };
                    return failSafeShare(opts);
                });
                return acc.concat(itemSharePromises);
            }, []));
        });
    }

    /**
     * Post process the Page models, interpolating various values which would
     * not have existed when the Page item itself was created
     * @param {object} siteModel Site Model
     * @param {object} pageModel Page Model
     * @private
     */
    function _secondPassAdlibPages(siteModel, pageModel) {
        // construct a hash of teams that were created and attached to the site
        var teams = [
            "collaborationGroupId",
            "followersGroupId",
            "contentGroupId"
        ].reduce(function (acc, prop) {
            var teamId = hubCommon.getProp(siteModel, "item.properties." + prop);
            if (teamId) {
                acc[prop] = teamId;
            }
            return acc;
        }, {});
        var settings = {
            teams: teams,
            siteId: hubCommon.getProp(siteModel, "item.id"),
            siteUrl: hubCommon.getProp(siteModel, "item.url"),
            initiative: {
                item: { id: hubCommon.getProp(siteModel, "item.properties.parentInitiativeId") }
            }
        };
        // weld in the site itself so it can be used for some interpolations
        settings[siteModel.key] = siteModel;
        return hubCommon.interpolate(pageModel, settings);
    }

    /**
     * Locate any Page items that were created in the Solution, and link them back to the Site
     * @param {object} siteModel Site Model
     * @param {Array} solutionModels Array of all models created by the Solution
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _updatePages(siteModel, solutionModels, hubRequestOptions) {
        // 2) for any page item, check if it has the site in it's pages array and if not add it
        var pageModels = solutionModels.filter(function (m) {
            return m.item.type.indexOf("Page") > -1;
        });
        // Create Fail-safe version of update b/c this is not critical
        var failSafeUpdate = hubCommon.failSafe(updateItem, { success: true });
        // check each one of these and see if the siteModel.item.id is in it's data.value.sites array
        // if not, add and update the item
        var siteEntry = {
            id: siteModel.item.id,
            title: siteModel.item.title
        };
        // iterate the pages
        return Promise.all(pageModels.map(function (m) {
            m.data.values.sites.push(siteEntry);
            m = _secondPassAdlibPages(siteModel, m);
            return failSafeUpdate({
                item: hubCommon.serializeModel(m),
                authentication: hubRequestOptions.authentication
            });
        }));
    }

    /**
     * Handle the Solution "Second Pass" for Site
     * @param {object} siteModel Site Model
     * @param {Array} solutionModels Array of all models created by the Solution
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function siteSecondPass(siteModel, solutionModels, hubRequestOptions) {
        var secondPassPromises = [];
        // get all the items that are not the site
        secondPassPromises = secondPassPromises.concat(_shareItemsToSiteGroups(siteModel, solutionModels, hubRequestOptions));
        // link the pages
        secondPassPromises = secondPassPromises.concat(_updatePages(siteModel, solutionModels, hubRequestOptions));
        return Promise.all(secondPassPromises);
    }

    /**
     * Get the data for a site item. Used by the UI to back-fill
     * a site model's `.data`, usually after we already have the item
     * as a result of a search.
     * Schema upgrades are applied.
     * @param {Object} item Site Item object
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function getDataForSiteItem(item, hubRequestOptions) {
        return getItemData(item.id, hubRequestOptions).then(function (data) {
            return hubCommon.upgradeSiteSchema({
                item: item,
                data: data,
            });
        });
    }

    // TODO: once the Hub API User Search is complete, integrate
    // it in this function for AGO users, and fallback to the
    // current implementation for enterprise users
    /**
     * Fetches and returns members given a list of usernames
     *
     * NOTE: AGO's user search endpoint is only available to
     * authenticated users; however, since unauthenticated users
     * should still be able to access public profiles, we support
     * fetching members for both unauthenticated/authenticated
     * users in this function
     *
     * @param {string[]} usernames List of usernames to search for
     * @param {object} requestOptions IHubRequestOptions
     */
    function getMembers(usernames, requestOptions) {
        return requestOptions.authentication
            ? authenticatedGetMembers(usernames, requestOptions)
            : unauthenticatedGetMembers(usernames, requestOptions);
    }
    /**
     * groups the provided usernames in chunks of 100 and creates query
     * strings to batch fetch those members from AGO's user search
     * (/community/users) endpoint. AGO will only return the subset of
     * members which the current user has access to.
     *
     * @param {Array} usernames List of usernames to search for
     * @param {object} requestOptions IHubRequestOptions
     */
    function authenticatedGetMembers(usernames, requestOptions) {
        var urlPath = hubCommon.getPortalUrl(requestOptions) + "/sharing/rest/community/users";
        var chunkSize = 100;
        var chunkedUsernames = [];
        for (var i = 0; i < usernames.length; i += chunkSize) {
            chunkedUsernames.push(usernames.slice(i, i + chunkSize));
        }
        var chunkedOptions = chunkedUsernames.map(function (chunk) {
            var q = chunk.map(function (username) { return "username:" + username; }).join(" OR ");
            return {
                urlPath: urlPath,
                requestOptions: __assign({ params: { q: q, num: chunk.length } }, requestOptions)
            };
        });
        return hubCommon.batch(chunkedOptions, batchMemberRequest).then(function (batchedMembers) {
            return batchedMembers.reduce(function (flat, toFlatten) {
                return flat.concat(toFlatten);
            }, []);
        });
    }
    /**
     * fetch members individually from AGO's /community/users/{username}
     * endpoint. This endpoint, unlike the users search endpoint which
     * only returns the subset of members that the current user has acces
     * to, will only limit the information returned for each member
     * (i.e. firstname, lastname and fullname will be empty strings if
     * an unauthenticated user tries to access a non-public profile).
     *
     * @param {Array} usernames List of usernames to search for
     * @param {object} requestOptions IHubRequestOptions
     */
    function unauthenticatedGetMembers(usernames, requestOptions) {
        return Promise.all(usernames.map(function (username) {
            return getUser(__assign({ username: username }, requestOptions))
                .then(function (response) {
                // if the firstname, lastname, and fullname are empty strings, assume that the
                // user is not accessible (i.e. not a public profile) and should not be returned
                // to the unauthenticated user
                if (response.firstName || response.lastName || response.fullName) {
                    return response;
                }
            })
                .catch(function (e) {
                hubCommon.Logger.error("Error fetching user, " + username + ", from AGO user endpoint, " + e);
                return null;
            });
        })).then(function (members) { return members.filter(Boolean); });
    }
    /**
     * callback function to batch the requests to the user search endpoint
     * if >100 usernames are supplied. This is necessary because the
     * endpoint sets the maximum number of results to be included in the
     * result set response to 100
     *
     * @param options IBatchMemberRequestOptions
     */
    function batchMemberRequest(options) {
        return request(options.urlPath, options.requestOptions)
            .then(function (response) { return response.results; })
            .catch(function (e) {
            hubCommon.Logger.error("Error fetching members from AGO user search endpoint: " + e);
            return [];
        });
    }

    Object.defineProperty(exports, 'DEFAULT_THEME', {
        enumerable: true,
        get: function () { return hubCommon.DEFAULT_THEME; }
    });
    Object.defineProperty(exports, 'addDomain', {
        enumerable: true,
        get: function () { return hubCommon.addDomain; }
    });
    Object.defineProperty(exports, 'buildDraft', {
        enumerable: true,
        get: function () { return hubCommon.buildDraft; }
    });
    Object.defineProperty(exports, 'domainExists', {
        enumerable: true,
        get: function () { return hubCommon.domainExists; }
    });
    Object.defineProperty(exports, 'domainExistsPortal', {
        enumerable: true,
        get: function () { return hubCommon.domainExistsPortal; }
    });
    Object.defineProperty(exports, 'ensureUniqueDomainName', {
        enumerable: true,
        get: function () { return hubCommon.ensureUniqueDomainName; }
    });
    Object.defineProperty(exports, 'getDomainsForSite', {
        enumerable: true,
        get: function () { return hubCommon.getDomainsForSite; }
    });
    Object.defineProperty(exports, 'getSiteById', {
        enumerable: true,
        get: function () { return hubCommon.getSiteById; }
    });
    Object.defineProperty(exports, 'getUniqueDomainName', {
        enumerable: true,
        get: function () { return hubCommon.getUniqueDomainName; }
    });
    Object.defineProperty(exports, 'getUniqueDomainNamePortal', {
        enumerable: true,
        get: function () { return hubCommon.getUniqueDomainNamePortal; }
    });
    Object.defineProperty(exports, 'isDomainForLegacySite', {
        enumerable: true,
        get: function () { return hubCommon.isDomainForLegacySite; }
    });
    Object.defineProperty(exports, 'isDomainUsedElsewhere', {
        enumerable: true,
        get: function () { return hubCommon.isDomainUsedElsewhere; }
    });
    Object.defineProperty(exports, 'isValidDomain', {
        enumerable: true,
        get: function () { return hubCommon.isValidDomain; }
    });
    Object.defineProperty(exports, 'lookupDomain', {
        enumerable: true,
        get: function () { return hubCommon.lookupDomain; }
    });
    Object.defineProperty(exports, 'removeDomain', {
        enumerable: true,
        get: function () { return hubCommon.removeDomain; }
    });
    Object.defineProperty(exports, 'updateDomain', {
        enumerable: true,
        get: function () { return hubCommon.updateDomain; }
    });
    Object.defineProperty(exports, 'upgradeSiteSchema', {
        enumerable: true,
        get: function () { return hubCommon.upgradeSiteSchema; }
    });
    exports.PAGE_DRAFT_INCLUDE_LIST = PAGE_DRAFT_INCLUDE_LIST;
    exports.PAGE_TEMPLATE_KEYWORD = PAGE_TEMPLATE_KEYWORD;
    exports.PAGE_TYPE_KEYWORD = PAGE_TYPE_KEYWORD;
    exports.SITE_DRAFT_INCLUDE_LIST = SITE_DRAFT_INCLUDE_LIST;
    exports.UNPUBLISHED_CHANGES_KW = UNPUBLISHED_CHANGES_KW;
    exports._addSiteDomains = _addSiteDomains;
    exports._createSiteInitiative = _createSiteInitiative;
    exports._ensureOptionalGroupsTemplating = _ensureOptionalGroupsTemplating;
    exports._ensurePortalDomainKeyword = _ensurePortalDomainKeyword;
    exports._ensureTypeAndTags = _ensureTypeAndTags;
    exports._getDraftResourceNames = _getDraftResourceNames;
    exports._getImageCropIdsFromLayout = _getImageCropIdsFromLayout;
    exports._getMostRecentDraftName = _getMostRecentDraftName;
    exports._getPortalDomainTypeKeyword = _getPortalDomainTypeKeyword;
    exports._getSecondPassSharingOptions = _getSecondPassSharingOptions;
    exports._getSiteDataById = _getSiteDataById;
    exports._includeListFromItemType = _includeListFromItemType;
    exports._removeParentInitiative = _removeParentInitiative;
    exports._removeSiteDomains = _removeSiteDomains;
    exports._removeSiteFromIndex = _removeSiteFromIndex;
    exports._removeSiteGroups = _removeSiteGroups;
    exports._secondPassAdlibPages = _secondPassAdlibPages;
    exports._shareItemsToSiteGroups = _shareItemsToSiteGroups;
    exports._updatePages = _updatePages;
    exports._updateTeamTags = _updateTeamTags;
    exports.applyDraft = applyDraft;
    exports.convertCard = convertCard;
    exports.convertLayoutToTemplate = convertLayoutToTemplate;
    exports.convertPageToTemplate = convertPageToTemplate;
    exports.convertRow = convertRow;
    exports.convertSection = convertSection;
    exports.convertSiteToTemplate = convertSiteToTemplate;
    exports.createPage = createPage;
    exports.createPageModelFromTemplate = createPageModelFromTemplate;
    exports.createSite = createSite;
    exports.createSiteModelFromTemplate = createSiteModelFromTemplate;
    exports.deleteDraft = deleteDraft;
    exports.ensureOptionalGroupsTemplating = ensureOptionalGroupsTemplating;
    exports.ensurePageHasSiteEntry = ensurePageHasSiteEntry;
    exports.ensureRequiredPageProperties = ensureRequiredPageProperties;
    exports.ensureRequiredSiteProperties = ensureRequiredSiteProperties;
    exports.extractAssets = extractAssets;
    exports.fetchAndApplyDraft = fetchAndApplyDraft;
    exports.fetchDraft = fetchDraft;
    exports.getCardDependencies = getCardDependencies;
    exports.getDataForSiteItem = getDataForSiteItem;
    exports.getDomain = getDomain;
    exports.getDomains = getDomains;
    exports.getDraftDate = getDraftDate;
    exports.getLayoutDependencies = getLayoutDependencies;
    exports.getMembers = getMembers;
    exports.getPageDependencies = getPageDependencies;
    exports.getPageEditUrl = getPageEditUrl;
    exports.getPageItemType = getPageItemType;
    exports.getPortalSiteHostname = getPortalSiteHostname;
    exports.getPortalSiteUrl = getPortalSiteUrl;
    exports.getRowDependencies = getRowDependencies;
    exports.getSectionDependencies = getSectionDependencies;
    exports.getSiteDependencies = getSiteDependencies;
    exports.getSiteEditUrl = getSiteEditUrl;
    exports.getSiteItemType = getSiteItemType;
    exports.getTheme = getTheme;
    exports.hasUnpublishedChanges = hasUnpublishedChanges;
    exports.interpolateSite = interpolateSite;
    exports.isPage = isPage;
    exports.isSite = isSite;
    exports.linkSiteAndPage = linkSiteAndPage;
    exports.markPublished = markPublished;
    exports.markUnpublished = markUnpublished;
    exports.registerBrowserApp = registerBrowserApp;
    exports.registerSiteAsApplication = registerSiteAsApplication;
    exports.removePage = removePage;
    exports.removeSite = removeSite;
    exports.removeSiteFromPage = removeSiteFromPage;
    exports.removeUnusedResources = removeUnusedResources;
    exports.saveDraft = saveDraft;
    exports.savePublishedStatus = savePublishedStatus;
    exports.shareItemsToSiteGroups = shareItemsToSiteGroups;
    exports.siteSecondPass = siteSecondPass;
    exports.unlinkPagesFromSite = unlinkPagesFromSite;
    exports.unlinkSiteAndPage = unlinkSiteAndPage;
    exports.updateAppRedirectUris = updateAppRedirectUris;
    exports.updatePage = updatePage;
    exports.updateSite = updateSite;
    exports.updateSiteApplicationUris = updateSiteApplicationUris;
    exports.upgradeDraftSchema = upgradeDraftSchema;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=sites.umd.js.map

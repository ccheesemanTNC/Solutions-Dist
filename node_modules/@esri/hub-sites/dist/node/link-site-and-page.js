"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkSiteAndPage = void 0;
const hub_common_1 = require("@esri/hub-common");
const arcgis_rest_portal_1 = require("@esri/arcgis-rest-portal");
const is_site_1 = require("./is-site");
/**
 * Link a Page and a Site, or vice-versa
 * This is a super tolerant function. It can be passed id's, models or a mix.
 * It will handle either the site or the page items being missing
 * It will handle cases where the current user lacks update privs to either item or rights
 * to change the sharing. Of course in those cases we clearly can't make the changes, and
 * this function will resolve as though they were made, usually the UI tier will have
 * ensured that the current user has write access to at least one of the main entities
 * @param {ILinkPageAndSiteRequestOptions} linkRequestOptions {siteModel || siteId, pageModel || pageId, authorization }
 */
function linkSiteAndPage(linkRequestOptions) {
    let shareGroups = [];
    const promises = [];
    let pageModel;
    let siteModel;
    const requestOptions = { authentication: linkRequestOptions.authentication };
    // get the models from the options...
    return Promise.all([
        hub_common_1.getModelFromOptions("page", linkRequestOptions),
        hub_common_1.getModelFromOptions("site", linkRequestOptions)
    ])
        .then(models => {
        // Should we handle either item being inaccessible?
        [pageModel, siteModel] = models;
        if (!siteModel.isMissing && !pageModel.isMissing) {
            // ensure we actually got a page and site
            if (!is_site_1.isSite(siteModel.item) ||
                !hub_common_1.includes(["Hub Page", "Site Page"], pageModel.item.type)) {
                return Promise.resolve([]);
            }
            // if we got a both...
            // Link the Site into the Page...
            const siteEntry = {
                id: siteModel.item.id,
                title: siteModel.item.title
            };
            if (!hub_common_1.getProp(pageModel, "data.values.sites")) {
                hub_common_1.deepSet(pageModel, "data.values.sites", []);
            }
            const sites = hub_common_1.getProp(pageModel, "data.values.sites");
            const hasSiteAlready = hub_common_1.includes(sites.map((p) => p.id), siteEntry.id);
            if (!hasSiteAlready) {
                pageModel.data.values.sites.push(siteEntry);
                const opts = Object.assign({ item: hub_common_1.serializeModel(pageModel) }, requestOptions);
                // Not failsafe - could reject
                promises.push(arcgis_rest_portal_1.updateItem(opts));
            }
            // Link the Page into the Site
            const pageEntry = {
                id: pageModel.item.id,
                title: pageModel.item.title
            };
            if (!hub_common_1.getProp(siteModel, "data.values.pages")) {
                hub_common_1.deepSet(siteModel, "data.values.pages", []);
            }
            const pages = hub_common_1.getProp(siteModel, "data.values.pages");
            const hasPageAlready = hub_common_1.includes(pages.map((p) => p.id), pageEntry.id);
            if (!hasPageAlready) {
                const slugs = hub_common_1.mapBy("slug", pages);
                // use the passed in slug, or generate a unique slug and add to the page entry...
                pageEntry.slug =
                    linkRequestOptions.pageSlug ||
                        hub_common_1.ensureUniqueString(slugs, hub_common_1.slugify(pageEntry.title));
                // push entry into pages array...
                siteModel.data.values.pages.push(pageEntry);
                // update the site item...
                const opts = Object.assign({ item: hub_common_1.serializeModel(siteModel) }, requestOptions);
                // Not failsafe - could reject
                promises.push(arcgis_rest_portal_1.updateItem(opts));
            }
            // Now we need to handle sharing of the Page to the site Collab & Content groups
            // The share functions handle pre-flights so we don't need to be concerned if the page is
            // somehow already shared to the group.
            shareGroups = hub_common_1.maybePush(hub_common_1.getProp(siteModel, "item.properties.collaborationGroupId"), shareGroups);
            shareGroups = hub_common_1.maybePush(hub_common_1.getProp(siteModel, "item.properties.contentGroupId"), shareGroups);
            // NOTE: Since sharing is limited to the owner || admin we failSafe the calls, and hope for the best.
            const failSafeShare = hub_common_1.failSafe(hub_common_1.shareItemToGroups);
            promises.push(failSafeShare(pageEntry.id, shareGroups, requestOptions));
            // return all the promises...
            return Promise.all(promises);
        }
        else {
            let msg = `The Page item (${pageModel.item.id}) is inaccessible.`;
            if (siteModel.isMissing) {
                if (pageModel.isMissing) {
                    msg = `Both the Page item (${pageModel.item.id}) and the Site item (${siteModel.item.id}) are inaccssible`;
                }
                else {
                    msg = `The Site item (${siteModel.item.id}) is inaccessible.`;
                }
            }
            throw new Error(`Linking Failed: ${msg}`);
        }
    })
        .then(() => {
        // Downside of optionally pusing entries into a promise array, is that you don't really know
        // what is in what index, so we really can't use the return values...
        return {
            pageModel,
            siteModel
        };
    })
        .catch((err) => {
        throw Error(`Error occured linking site ${siteModel.item.id} with ${pageModel.item.id}: ${err}`);
    });
}
exports.linkSiteAndPage = linkSiteAndPage;
//# sourceMappingURL=link-site-and-page.js.map
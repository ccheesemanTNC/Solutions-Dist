"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateSite = void 0;
const hub_common_1 = require("@esri/hub-common");
const site_ui_version_1 = require("./site-ui-version");
const _ensure_portal_domain_keyword_1 = require("./_ensure-portal-domain-keyword");
const arcgis_rest_portal_1 = require("@esri/arcgis-rest-portal");
/**
 * Update an existing site item
 * This function supports the equivalent of a PATCH REST operation
 * It will fetch the current item from ago, and then apply
 * a subset of property changes to the model if a allowList is included.
 * The allowList can include any property paths on the item.
 * If the list is empty, then the entire site model is overwritten.
 * @param {Object} model Site Model to update
 * @param {IUpdateSiteOptions} updateSiteOptions
 */
function updateSite(model, updateSiteOptions) {
    const allowList = updateSiteOptions.allowList || [];
    const { updateVersions = true } = updateSiteOptions;
    // apply any on-save site upgrades here...
    hub_common_1.deepSet(model, "data.values.uiVersion", site_ui_version_1.SITE_UI_VERSION);
    hub_common_1.deepSet(model, "data.values.updatedAt", new Date().toISOString());
    hub_common_1.deepSet(model, "data.values.updatedBy", updateSiteOptions.authentication.username);
    // we only add these in if an allowList was passed in
    if (allowList.length) {
        allowList.push("data.values.updatedAt");
        allowList.push("data.values.updatedBy");
        if (updateVersions) {
            allowList.push("data.values.uiVersion");
            // any save needs to be able to update the schema version
            // which will have been bumped if a schema migration
            // occured during the load cycle
            allowList.push("item.properties.schemaVersion");
        }
    }
    // PORTAL-ENV: no domain service so we encode the subdomain in a typeKeyword
    if (updateSiteOptions.isPortal) {
        model.item.typeKeywords = _ensure_portal_domain_keyword_1._ensurePortalDomainKeyword(hub_common_1.getProp(model, "data.values.subdomain"), model.item.typeKeywords);
        // see above comment why ths is gated...
        if (allowList.length) {
            allowList.push("item.typeKeywords");
        }
    }
    // Actually start the update process...
    let agoModelPromise;
    // if we have a allowList, refetch the site to check for changes...
    if (allowList.length) {
        agoModelPromise = hub_common_1.getSiteById(model.item.id, updateSiteOptions);
    }
    else {
        // if we dont have a allowList, just resolve with the model we have
        agoModelPromise = Promise.resolve(model);
    }
    // Kick things off...
    return agoModelPromise
        .then((agoModel) => {
        if (allowList.length) {
            // merge the props in the allow list into the model from AGO
            model = hub_common_1.mergeObjects(model, agoModel, allowList);
        }
        // send the update to ago
        return arcgis_rest_portal_1.updateItem({
            item: hub_common_1.serializeModel(model),
            authentication: updateSiteOptions.authentication,
            params: { clearEmptyFields: true },
        });
    })
        .catch((err) => {
        throw Error(`updateSite: Error updating site: ${err}`);
    });
}
exports.updateSite = updateSite;
//# sourceMappingURL=update-site.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unlinkSiteAndPage = void 0;
const hub_common_1 = require("@esri/hub-common");
/**
 * Unlink a Page from a Site and vice-versa
 * This is a super tolerant function. It can be passed ids, models or a mix.
 * It will handle either the site or the page items being missing
 * It will handle cases where the current user lacks update privs to either item or rights
 * to change the sharing. Of course in those cases we clearly can't make the changes, and
 * this function will resolve as though they were made, usually the UI tier will have
 * ensured that the current user has write access to at least one of the main entities
 * @param {IUnlinkRequestOptions} unlinkRequestOptions {siteModel || siteId, pageModel || pageId, authorization...}
 */
function unlinkSiteAndPage(unlinkRequestOptions) {
    let unshareGroups = [];
    const promises = [];
    let pageModel;
    let siteModel;
    const requestOptions = {
        authentication: unlinkRequestOptions.authentication
    };
    // get the models from the options...
    return Promise.all([
        hub_common_1.getModelFromOptions("page", unlinkRequestOptions),
        hub_common_1.getModelFromOptions("site", unlinkRequestOptions)
    ])
        .then(models => {
        [pageModel, siteModel] = models;
        // Handle the site
        if (!siteModel.isMissing) {
            const pages = hub_common_1.getWithDefault(siteModel, "data.values.pages", []);
            // remove the page from the pages array on the model
            siteModel.data.values.pages = hub_common_1.withoutByProp("id", pageModel.item.id, pages);
            // collect the groups we'll unshare the page from
            unshareGroups = hub_common_1.maybePush(hub_common_1.getProp(siteModel, "item.properties.collaborationGroupId"), unshareGroups);
            unshareGroups = hub_common_1.maybePush(hub_common_1.getProp(siteModel, "item.properties.contentGroupId"), unshareGroups);
            // update the site, but failSafe so we don't have to do any checking if the current user can update it
            promises.push(hub_common_1.failSafeUpdate(siteModel, requestOptions));
        }
        // Handle the page
        if (!pageModel.isMissing) {
            const sites = hub_common_1.getWithDefault(pageModel, "data.values.sites", []);
            // remove site from sites array on the model
            pageModel.data.values.sites = hub_common_1.withoutByProp("id", siteModel.item.id, sites);
            promises.push(hub_common_1.failSafeUpdate(pageModel, requestOptions));
            // now about the groups
            const failSafeUnshare = hub_common_1.failSafe(hub_common_1.unshareItemFromGroups);
            promises.push(failSafeUnshare(pageModel.item.id, unshareGroups, requestOptions));
        }
        return Promise.all(promises);
    })
        .then(() => {
        // return the updated models
        return {
            pageModel,
            siteModel
        };
    });
}
exports.unlinkSiteAndPage = unlinkSiteAndPage;
//# sourceMappingURL=unlink-site-and-page.js.map
import { __awaiter, __generator } from "tslib";
import { getProp, emailOrgUsers } from "@esri/hub-common";
/**
 * @private
 * Governs the logic for emailing N users. It acts under the assumption
 * that all the 'community' users are the ones being emailed (this is due to platform rules we conform to)
 * Function is called upstream depending on if an email object is attached to the context.
 * Email object contains its own auth as it'll require the community admin to send the email itself.
 * An individual email call goes out for each user due to how the response of multiple users in a single call works.
 *
 * @export
 * @param {IAddOrInviteContext} context context object
 * @return {IAddOrInviteResponse} response object
 */
export function processEmailUsers(context) {
    return __awaiter(this, void 0, void 0, function () {
        var users, notEmailed, errors, _i, users_1, user, emailResponse;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    users = getProp(context, "community");
                    notEmailed = [];
                    errors = [];
                    _i = 0, users_1 = users;
                    _a.label = 1;
                case 1:
                    if (!(_i < users_1.length)) return [3 /*break*/, 4];
                    user = users_1[_i];
                    return [4 /*yield*/, emailOrgUsers([user], getProp(context, "email.message"), getProp(context, "email.auth"), true)];
                case 2:
                    emailResponse = _a.sent();
                    // If it's just a failed email
                    // then add username to notEmailed array
                    if (!emailResponse.success) {
                        notEmailed.push(user.username);
                        // If there was a legit error
                        // Then only the error returns from
                        // online. Add error AND include username in notEmailed array.
                        if (emailResponse.errors) {
                            errors = errors.concat(emailResponse.errors);
                        }
                    }
                    _a.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: 
                // if you leave out any of the props
                // from the final object and you are concatting together arrays you can concat
                // an undeifined inside an array which will throw off array lengths.
                return [2 /*return*/, {
                        users: users.map(function (u) { return u.username; }),
                        notEmailed: notEmailed,
                        errors: errors,
                        notInvited: [],
                        notAdded: [],
                    }];
            }
        });
    });
}
//# sourceMappingURL=process-email-users.js.map
import { __awaiter, __generator } from "tslib";
import { getProp } from "@esri/hub-common";
import { getTeamById } from "./get-team-by-id";
import { canUserCreateTeam } from "./can-user-create-team";
import { TYPEMAP } from "./type-map";
/**
 * Given an item, a teamType and a user, return the status
 * of the team ('ok', 'missing', 'broken', 'fixable' ), along
 * with specific details:
 * id: id of the group
 * isMissing: was the group simply never created?
 * isBroken: true if the item has an id for the group, but the group can not be found
 * canFix: true if user can create the group
 * If a team that a route depends on returns `isBroken` the route should redirect
 * to /teams/repair, which will do a full inspection, list things that are broken
 * and then conduct any repairs that can be done. It will list the issues, with
 * the intent of training customers to NOT mess with Team groups in AGO.
 * Once repairs are complete, the user will click a button to return to the route they
 * we attempting to enter before this diversion.
 *
 * @export
 * @param {IItem} item Site or Initiative ITEM (not model)
 * @param {("core" | "content" | "followers")} teamType Type of team to check for
 * @param {IUser} user User Object
 * @param {IHubRequestOptions} ro Auth
 * @return {*}  {Promise<ITeamStatus>}
 */
export function getTeamStatus(item, teamType, user, ro) {
    return __awaiter(this, void 0, void 0, function () {
        var result, id, group, _a, ex_1, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    result = {
                        teamType: teamType,
                        id: null,
                        isOk: false,
                        isMissing: true,
                        isBroken: false,
                        canFix: false,
                        isMember: false,
                    };
                    id = getProp(getProp(item, "properties"), TYPEMAP[teamType]);
                    if (!id) return [3 /*break*/, 9];
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 6, , 8]);
                    return [4 /*yield*/, getTeamById(id, ro)];
                case 2:
                    group = _d.sent();
                    if (!group) return [3 /*break*/, 3];
                    result.id = id;
                    result.isOk = true;
                    result.isMissing = false;
                    return [3 /*break*/, 5];
                case 3:
                    // If it doesn't, then check to see if user can Create team
                    result.id = id;
                    result.isBroken = true;
                    _a = result;
                    return [4 /*yield*/, canUserCreateTeam(user, teamType, ro)];
                case 4:
                    _a.canFix = _d.sent();
                    _d.label = 5;
                case 5: return [3 /*break*/, 8];
                case 6:
                    ex_1 = _d.sent();
                    // If the search errors then check if user can create team
                    result.id = id;
                    result.isBroken = true;
                    _b = result;
                    return [4 /*yield*/, canUserCreateTeam(user, teamType, ro)];
                case 7:
                    _b.canFix = _d.sent();
                    return [3 /*break*/, 8];
                case 8: return [3 /*break*/, 11];
                case 9:
                    // If there is not an id then check if the user can create the team
                    _c = result;
                    return [4 /*yield*/, canUserCreateTeam(user, teamType, ro)];
                case 10:
                    // If there is not an id then check if the user can create the team
                    _c.canFix = _d.sent();
                    _d.label = 11;
                case 11: return [2 /*return*/, result];
            }
        });
    });
}
//# sourceMappingURL=get-team-status.js.map
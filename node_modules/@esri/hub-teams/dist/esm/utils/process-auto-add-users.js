import { __awaiter, __generator } from "tslib";
import { autoAddUsers, getProp } from "@esri/hub-common";
import { autoAddUsersAsAdmins } from "./auto-add-users-as-admins";
import { processEmailUsers } from "./process-email-users";
/**
 * @private
 * Governs logic for automatically adding N users to a group.
 * Users are added as either a regular user OR as an administrator of the group
 * depending on the addUserAsGroupAdmin prop on the IAddOrInviteContext.
 * If there is an email object on the IAddOrInviteContext, then email notifications are sent.
 *
 * @export
 * @param {IAddOrInviteContext} context context object
 * @param {string} userType what type of user is it: org | world | community
 * @param {boolean} [shouldEmail=false] should the user be emailed?
 * @return {IAddOrInviteResponse} response object
 */
export function processAutoAddUsers(context, userType, shouldEmail) {
    if (shouldEmail === void 0) { shouldEmail = false; }
    return __awaiter(this, void 0, void 0, function () {
        var users, autoAddResponse, emailResponse, notAdded, errors, addUserAsGroupAdmin;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    users = getProp(context, userType);
                    notAdded = [];
                    errors = [];
                    addUserAsGroupAdmin = context.addUserAsGroupAdmin;
                    if (!addUserAsGroupAdmin) return [3 /*break*/, 2];
                    return [4 /*yield*/, autoAddUsersAsAdmins(getProp(context, "groupId"), users, getProp(context, "primaryRO"))];
                case 1:
                    // if is core team we elevate user to admin
                    autoAddResponse = _a.sent();
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, autoAddUsers(getProp(context, "groupId"), users, getProp(context, "primaryRO"))];
                case 3:
                    // if not then we are just auto adding them
                    autoAddResponse = _a.sent();
                    _a.label = 4;
                case 4:
                    // handle notAdded users
                    if (autoAddResponse.notAdded) {
                        notAdded = notAdded.concat(autoAddResponse.notAdded);
                    }
                    // Merge errors into empty array
                    if (autoAddResponse.errors) {
                        errors = errors.concat(autoAddResponse.errors);
                    }
                    if (!shouldEmail) return [3 /*break*/, 6];
                    return [4 /*yield*/, processEmailUsers(context)];
                case 5:
                    emailResponse = _a.sent();
                    // merge errors in to overall errors array to keep things flat
                    if (emailResponse.errors && emailResponse.errors.length > 0) {
                        errors = errors.concat(emailResponse.errors);
                    }
                    _a.label = 6;
                case 6: 
                // if you leave out any of the props
                // from the final object and you are concatting together arrays you can concat
                // an undeifined inside an array which will throw off array lengths.
                return [2 /*return*/, {
                        users: users.map(function (u) { return u.username; }),
                        notAdded: notAdded,
                        errors: errors,
                        notEmailed: (emailResponse === null || emailResponse === void 0 ? void 0 : emailResponse.notEmailed) || [],
                        notInvited: [],
                    }];
            }
        });
    });
}
//# sourceMappingURL=process-auto-add-users.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processAutoAddUsers = void 0;
const hub_common_1 = require("@esri/hub-common");
const auto_add_users_as_admins_1 = require("./auto-add-users-as-admins");
const process_email_users_1 = require("./process-email-users");
/**
 * @private
 * Governs logic for automatically adding N users to a group.
 * Users are added as either a regular user OR as an administrator of the group
 * depending on the addUserAsGroupAdmin prop on the IAddOrInviteContext.
 * If there is an email object on the IAddOrInviteContext, then email notifications are sent.
 *
 * @export
 * @param {IAddOrInviteContext} context context object
 * @param {string} userType what type of user is it: org | world | community
 * @param {boolean} [shouldEmail=false] should the user be emailed?
 * @return {IAddOrInviteResponse} response object
 */
async function processAutoAddUsers(context, userType, shouldEmail = false) {
    // fetch users out of context object
    const users = hub_common_1.getProp(context, userType);
    let autoAddResponse;
    let emailResponse;
    let notAdded = [];
    let errors = [];
    // fetch addUserAsGroupAdmin out of context
    const { addUserAsGroupAdmin } = context;
    if (addUserAsGroupAdmin) {
        // if is core team we elevate user to admin
        autoAddResponse = await auto_add_users_as_admins_1.autoAddUsersAsAdmins(hub_common_1.getProp(context, "groupId"), users, hub_common_1.getProp(context, "primaryRO"));
    }
    else {
        // if not then we are just auto adding them
        autoAddResponse = await hub_common_1.autoAddUsers(hub_common_1.getProp(context, "groupId"), users, hub_common_1.getProp(context, "primaryRO"));
    }
    // handle notAdded users
    if (autoAddResponse.notAdded) {
        notAdded = notAdded.concat(autoAddResponse.notAdded);
    }
    // Merge errors into empty array
    if (autoAddResponse.errors) {
        errors = errors.concat(autoAddResponse.errors);
    }
    // run email process
    if (shouldEmail) {
        emailResponse = await process_email_users_1.processEmailUsers(context);
        // merge errors in to overall errors array to keep things flat
        if (emailResponse.errors && emailResponse.errors.length > 0) {
            errors = errors.concat(emailResponse.errors);
        }
    }
    // if you leave out any of the props
    // from the final object and you are concatting together arrays you can concat
    // an undeifined inside an array which will throw off array lengths.
    return {
        users: users.map((u) => u.username),
        notAdded,
        errors,
        notEmailed: (emailResponse === null || emailResponse === void 0 ? void 0 : emailResponse.notEmailed) || [],
        notInvited: [],
    };
}
exports.processAutoAddUsers = processAutoAddUsers;
//# sourceMappingURL=process-auto-add-users.js.map
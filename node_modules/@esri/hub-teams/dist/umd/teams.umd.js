/* @preserve
 * @esri/hub-teams - v9.28.0 - Thu Apr 21 2022 15:28:16 GMT+0000 (Coordinated Universal Time)
 * Copyright (c) 2022 Environmental Systems Research Institute, Inc.
 * Apache-2.0
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@esri/hub-common')) :
    typeof define === 'function' && define.amd ? define(['exports', '@esri/hub-common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.arcgisHub = global.arcgisHub || {}, global.arcgisHub));
})(this, (function (exports, hubCommon) { 'use strict';

    /**
     * Enum of the types of teams that the teams service supports
     */
    var TEAMTYPES = [
        "core",
        "content",
        "followers",
        "team",
        "event",
        "edit",
    ];

    /**
     * Attempts to Add, Invite, or email users about joining
     * a team depending on the requesting user's permissions
     * (see addUsersToGroup in hub-common)
     *
     * @param {string} groupId
     * @param {IUser[]} usersToAdd
     * @param {IHubRequestOptions} primaryRO Info and authentication for the requesting user
     * @param {IEmail} [email] Email to be sent (if qualifying users are passed in)
     * @param {IHubRequestOptions} [secondaryRO] Info and authentication for emailing members of a secondary organization (typically a community org)
     *
     * @returns {IConsolidatedResult} The operations attempted, whether they were successful and any errors
     */
    function addUsersToTeam(teamId, usersToAdd, primaryRO, email, secondaryRO) {
        return hubCommon.addUsersToGroup(teamId, usersToAdd, primaryRO, email, secondaryRO);
    }

    /**
     * Hash of the team group templates.
     * This hash is used to determin what teams can be created in what products
     * based on what privs and stored in what properties
     * We define the various groups via json structures. The .config hash controls
     * the i18n, as well as the portal vs ago, and basic vs premium definition.
     * This allows us to add/remove/edit groups by simply modifying this hash
     * instead of spreading complex construction logic all over the application
     */
    var WELLKNOWNTEAMS = [
        {
            config: {
                groupType: "Hub Collaboration Group",
                type: "core",
                availableIn: ["premium"],
                propertyName: "collaborationGroupId",
                requiredPrivs: ["portal:admin:createUpdateCapableGroup"],
                titleI18n: "collaborationTitle",
                descriptionI18n: "collaborationDesc",
                snippetI18n: "collaborationSnippet",
                privPropValues: [
                    {
                        priv: "portal:user:addExternalMembersToGroup",
                        prop: "membershipAccess",
                        value: "collaboration",
                    },
                ],
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            capabilities: "updateitemcontrol",
            membershipAccess: "org",
            _edit_privacy: "on",
            _edit_contributors: "on",
            tags: [
                "Hub Group",
                "Hub Initiative Group",
                "Hub Site Group",
                "Hub Core Team Group",
                "Hub Team Group",
            ],
        },
        {
            config: {
                groupType: "Hub Collaboration Group",
                type: "core",
                availableIn: ["basic"],
                propertyName: "collaborationGroupId",
                requiredPrivs: ["portal:admin:createUpdateCapableGroup"],
                titleI18n: "collaborationTitleBasic",
                descriptionI18n: "collaborationDescBasic",
                snippetI18n: "collaborationSnippetBasic",
                privPropValues: [
                    {
                        priv: "portal:user:addExternalMembersToGroup",
                        prop: "membershipAccess",
                        value: "collaboration",
                    },
                ],
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            capabilities: "updateitemcontrol",
            membershipAccess: "org",
            _edit_privacy: "on",
            _edit_contributors: "on",
            tags: [
                "Hub Group",
                "Hub Site Group",
                "Hub Core Team Group",
                "Hub Team Group",
            ],
        },
        {
            config: {
                groupType: "Portal Collaboration Group",
                type: "core",
                availableIn: ["portal"],
                propertyName: "collaborationGroupId",
                requiredPrivs: [
                    "portal:user:createGroup",
                    "portal:admin:createUpdateCapableGroup",
                ],
                titleI18n: "collaborationTitlePortal",
                descriptionI18n: "collaborationDescPortal",
                snippetI18n: "collaborationSnippetPortal",
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            capabilities: "updateitemcontrol",
            _edit_privacy: "on",
            _edit_contributors: "on",
            tags: ["Sites Group", "Sites Core Team Group"],
        },
        {
            config: {
                groupType: "Hub Content Group",
                type: "content",
                availableIn: ["premium"],
                propertyName: "contentGroupId",
                requiredPrivs: ["portal:user:createGroup"],
                titleI18n: "contentTitle",
                descriptionI18n: "contentDesc",
                snippetI18n: "contentSnippet",
                privPropValues: [
                    {
                        priv: "portal:user:addExternalMembersToGroup",
                        prop: "membershipAccess",
                        value: "",
                    },
                ],
            },
            access: "public",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            membershipAccess: "org",
            tags: [
                "Hub Group",
                "Hub Content Group",
                "Hub Site Group",
                "Hub Initiative Group",
            ],
        },
        {
            config: {
                groupType: "Hub Content Group",
                type: "content",
                availableIn: ["basic"],
                propertyName: "contentGroupId",
                requiredPrivs: ["portal:user:createGroup"],
                titleI18n: "contentTitleBasic",
                descriptionI18n: "contentDescBasic",
                snippetI18n: "contentSnippetBasic",
                privPropValues: [
                    {
                        priv: "portal:user:addExternalMembersToGroup",
                        prop: "membershipAccess",
                        value: "",
                    },
                ],
            },
            access: "public",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            membershipAccess: "org",
            tags: ["Hub Group", "Hub Content Group", "Hub Site Group"],
        },
        {
            config: {
                groupType: "Portal Content Group",
                type: "content",
                availableIn: ["portal"],
                propertyName: "contentGroupId",
                requiredPrivs: ["portal:user:createGroup"],
                titleI18n: "contentTitle",
                descriptionI18n: "contentDescPortal",
                snippetI18n: "contentSnippetPortal",
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            tags: ["Sites Group", "Sites Content Group"],
        },
        {
            // this is only ever created in AGO, so we don't have a second entry for followers
            config: {
                groupType: "Hub Followers Group",
                type: "followers",
                availableIn: ["premium"],
                propertyName: "followersGroupId",
                requiredPrivs: ["portal:user:createGroup"],
                titleI18n: "followersTitle",
                descriptionI18n: "followersDesc",
                snippetI18n: "followersSnippet",
                privPropValues: [
                    {
                        priv: "portal:user:addExternalMembersToGroup",
                        prop: "membershipAccess",
                        value: "",
                    },
                ],
            },
            access: "public",
            autoJoin: true,
            isInvitationOnly: false,
            isViewOnly: true,
            notificationsEnabled: true,
            sortField: "title",
            sortOrder: "asc",
            membershipAccess: "org",
            tags: [
                "Hub Group",
                "Hub Initiative Followers Group",
                "Hub Initiative Group",
            ],
        },
        {
            config: {
                groupType: "Generic AGO Site Team",
                type: "team",
                availableIn: ["basic"],
                requiredPrivs: ["portal:user:createGroup"],
                titleI18n: "teamTitle",
                descriptionI18n: "teamDesc",
                snippetI18n: "teamSnippet",
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            tags: ["Site Team Group"],
        },
        {
            config: {
                groupType: "Generic AGO Initiative Team",
                type: "team",
                availableIn: ["premium"],
                requiredPrivs: [
                    "portal:user:createGroup",
                    "portal:user:addExternalMembersToGroup",
                ],
                titleI18n: "teamTitle",
                descriptionI18n: "teamDesc",
                snippetI18n: "teamSnippet",
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            membershipAccess: "",
            tags: ["Hub Team Group"],
        },
        {
            config: {
                groupType: "Generic AGO Edit Supporting Team",
                type: "edit",
                availableIn: ["premium"],
                requiredPrivs: [
                    "portal:user:createGroup",
                    "portal:user:addExternalMembersToGroup",
                ],
                titleI18n: "teamTitle",
                descriptionI18n: "editTeamDesc",
                snippetI18n: "editTeamSnippet",
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            capabilities: "updateitemcontrol",
            membershipAccess: "org",
            tags: ["Hub Team Group"],
            typekeyword: ["Hub Team", "Hub Edit Supporting Team"],
        },
        {
            config: {
                groupType: "Generic Portal Edit Supporting Team",
                type: "edit",
                availableIn: ["portal"],
                requiredPrivs: ["portal:user:createGroup"],
                titleI18n: "teamTitle",
                descriptionI18n: "editTeamDesc",
                snippetI18n: "editTeamSnippet",
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            capabilities: "updateitemcontrol",
            membershipAccess: "org",
            tags: ["Site Team Group"],
            typekeyword: ["Site Team", "Site Edit Supporting Team"],
        },
        {
            config: {
                groupType: "Generic Portal Team",
                type: "team",
                availableIn: ["portal"],
                requiredPrivs: ["portal:user:createGroup"],
                titleI18n: "teamTitle",
                descriptionI18n: "teamDesc",
                snippetI18n: "teamSnippet",
            },
            access: "org",
            autoJoin: false,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "modified",
            sortOrder: "desc",
            tags: ["Site Team Group"],
        },
        {
            config: {
                groupType: "Generic Event Team",
                type: "event",
                availableIn: ["premium"],
                requiredPrivs: [
                    "portal:user:createGroup",
                    "portal:user:addExternalMembersToGroup",
                ],
                titleI18n: "eventTeamTitle",
                descriptionI18n: "eventTeamDesc",
                snippetI18n: "eventTeamSnippet",
            },
            access: "public",
            autoJoin: true,
            isInvitationOnly: false,
            isViewOnly: false,
            sortField: "title",
            sortOrder: "asc",
            membershipAccess: "",
            tags: ["Hub Group", "Hub Event Group", "Hub Initiative Group"],
        },
    ];

    /**
     * Does a user have all the privileges in the passed in array
     * @param {current user from session} user
     * @param {array} privileges
     */
    function hasAllPrivileges(user, privileges) {
        var result = false;
        // ensure we were passed an array...
        if (Array.isArray(privileges)) {
            result = privileges.every(function (priv) { return user.privileges.indexOf(priv) > -1; });
        }
        return result;
    }

    /**
     * Predicate for filtering group templates based on product
     * and user privs required.
     * Param order is optimized for partial application
     * @param {object} user
     * @param {string} product basic, premium, portal
     * @param {object} template Team (group) template
     */
    function canUserCreateTeamInProduct(user, product, template) {
        var result = false;
        var userGroups = hubCommon.getProp(user, "groups") || [];
        // can this be created in the current environment?
        if (userGroups.length < 507 &&
            hubCommon.includes(template.config.availableIn, product)) {
            // and user has required privs...
            result = hasAllPrivileges(user, template.config.requiredPrivs);
        }
        return result;
    }

    var ALLOWED_SUBSCRIPTION_TYPES = [
        "Demo & Marketing",
        "Demo and Marketing",
        "Organizational Plan",
        "Community",
        "In House",
        "ConnectED",
        "ELA",
        "Education Site License",
        "Education",
        "HUP Online",
    ];
    /**
     * TODO: If/when AGO implements this logic or runs a script on their end we can remove
     * this logic, or simply return passed in user.
     * Returns a cloned copy of the user object with updated privileges
     * based on whether or not the user has a subscription type not in the
     * allowed list
     * @param {object} user
     * @param {string} subscriptionInfoType
     * @returns
     */
    function removeInvalidPrivs(user, subscriptionInfoType) {
        // Clone User
        var clonedUser = hubCommon.cloneObject(user);
        // Get allowed list of sub types
        var allowedSubscriptionTypes = ALLOWED_SUBSCRIPTION_TYPES;
        // If portal self has a sub type OTHER than one of the allowed ones...
        if (!hubCommon.includes(allowedSubscriptionTypes, subscriptionInfoType)) {
            clonedUser.privileges = hubCommon.without(clonedUser.privileges, "portal:user:addExternalMembersToGroup");
        }
        return clonedUser;
    }

    /**
     * Updates template based upon new privPropValues property
     * In the templates config hash.
     * This allows us to conditionally change out parts of the template
     * @param {object} user
     * @param {object} template
     * @returns {object} Returns updated template
     */
    function applyPrivPropValuesToTemplate(user, template) {
        var templateCopy = hubCommon.cloneObject(template);
        // Only two templates actually have this in config atm, so we want to be safe.
        var ppv = hubCommon.getWithDefault(template, "config.privPropValues", []);
        // iterate over privPropValues
        ppv.forEach(function (entry) {
            // entry === each privPropValue obj { priv, prop, value}
            // If user privileges includes the privilege in privPropValue...
            if (hubCommon.includes(user.privileges, entry.priv)) {
                // update the group template with appropriate prop / value changes
                templateCopy[entry.prop] = entry.value; // for example updating the membershipAccess
            }
        });
        return templateCopy;
    }

    // TODO: Remove portalApiVersion at next breaking change
    /**
     * Return array of group templates that the current user has licensing
     * and privs to create in the current environment (AGO vs Portal)
     * @param {object} user
     * @param {string} environment
     * @param {string} portalApiVersion
     * @param {string} subscriptionInfoType
     */
    function getUserCreatableTeams(user, environment, portalApiVersion, // Depracated, remove at next breaking change
    subscriptionInfoType) {
        if (subscriptionInfoType === void 0) { subscriptionInfoType = ""; }
        /* tslint:disable no-console */
        console.warn("Hub.js::getUserCreatableTeams Deprecation warning portalApiVersion will be removed at v9.0.0");
        /* tslint:enable no-console */
        var teams = WELLKNOWNTEAMS;
        // Online is not properly respecting addExternalMembersToGroup for
        // certain subscription types known ones so far: Trial, personal use, developer, and evaluation
        var updatedUser = removeInvalidPrivs(user, subscriptionInfoType);
        // Update templates and remove the ones that aren't applicable.
        return hubCommon.cloneObject(teams).reduce(function (acc, teamTmpl) {
            // Update template based on privPropValue
            var copyTemplate = applyPrivPropValuesToTemplate(updatedUser, teamTmpl);
            // If the user can create the team....
            if (canUserCreateTeamInProduct(updatedUser, environment, copyTemplate)) {
                // Add the team to the accumulator
                acc.push(copyTemplate);
            }
            return acc;
        }, []);
    }

    /**
     * Inject the translations into the Group object template
     * @param {object} template Json Template for the Group
     * @param {string} title Group Title
     * @param {object} translation Translation json
     * @private
     */
    function _translateTeamTemplate(template, title, translation) {
        // the team template has the i18n keys in a configuration hash
        // we iterate those properties...
        ["titleI18n", "descriptionI18n", "snippetI18n"].forEach(function (key) {
            // get the actual i18n key from the template itself
            var i18nKey = template.config[key];
            // compute the target property name by removing the I18n
            var targetProp = key.replace("I18n", "");
            // get the translation out of the translation file we fetched
            var val = hubCommon.getProp(translation, "addons.services.teams.groups." + i18nKey);
            // interpolate the title name into the translation string
            template[targetProp] = val.replace(/{title}/g, title);
        });
        return template;
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Checks parameters to see if we should use FormData to send the request
     * @param params The object whose keys will be encoded.
     * @return A boolean indicating if FormData will be required.
     */
    function requiresFormData(params) {
        return Object.keys(params).some(function (key) {
            var value = params[key];
            if (!value) {
                return false;
            }
            if (value && value.toParam) {
                value = value.toParam();
            }
            var type = value.constructor.name;
            switch (type) {
                case "Array":
                    return false;
                case "Object":
                    return false;
                case "Date":
                    return false;
                case "Function":
                    return false;
                case "Boolean":
                    return false;
                case "String":
                    return false;
                case "Number":
                    return false;
                default:
                    return true;
            }
        });
    }
    /**
     * Converts parameters to the proper representation to send to the ArcGIS REST API.
     * @param params The object whose keys will be encoded.
     * @return A new object with properly encoded values.
     */
    function processParams(params) {
        var newParams = {};
        Object.keys(params).forEach(function (key) {
            var _a, _b;
            var param = params[key];
            if (param && param.toParam) {
                param = param.toParam();
            }
            if (!param &&
                param !== 0 &&
                typeof param !== "boolean" &&
                typeof param !== "string") {
                return;
            }
            var type = param.constructor.name;
            var value;
            // properly encodes objects, arrays and dates for arcgis.com and other services.
            // ported from https://github.com/Esri/esri-leaflet/blob/master/src/Request.js#L22-L30
            // also see https://github.com/Esri/arcgis-rest-js/issues/18:
            // null, undefined, function are excluded. If you want to send an empty key you need to send an empty string "".
            switch (type) {
                case "Array":
                    // Based on the first element of the array, classify array as an array of arrays, an array of objects
                    // to be stringified, or an array of non-objects to be comma-separated
                    // eslint-disable-next-line no-case-declarations
                    var firstElementType = (_b = (_a = param[0]) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name;
                    value =
                        firstElementType === "Array" ? param : // pass thru array of arrays
                            firstElementType === "Object" ? JSON.stringify(param) : // stringify array of objects
                                param.join(","); // join other types of array elements
                    break;
                case "Object":
                    value = JSON.stringify(param);
                    break;
                case "Date":
                    value = param.valueOf();
                    break;
                case "Function":
                    value = null;
                    break;
                case "Boolean":
                    value = param + "";
                    break;
                default:
                    value = param;
                    break;
            }
            if (value || value === 0 || typeof value === "string" || Array.isArray(value)) {
                newParams[key] = value;
            }
        });
        return newParams;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes keys and parameters for use in a URL's query string.
     *
     * @param key Parameter's key
     * @param value Parameter's value
     * @returns Query string with key and value pairs separated by "&"
     */
    function encodeParam(key, value) {
        // For array of arrays, repeat key=value for each element of containing array
        if (Array.isArray(value) && value[0] && Array.isArray(value[0])) {
            return value.map(function (arrayElem) { return encodeParam(key, arrayElem); }).join("&");
        }
        return encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
    /**
     * Encodes the passed object as a query string.
     *
     * @param params An object to be encoded.
     * @returns An encoded query string.
     */
    function encodeQueryString(params) {
        var newParams = processParams(params);
        return Object.keys(newParams)
            .map(function (key) {
            return encodeParam(key, newParams[key]);
        })
            .join("&");
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Encodes parameters in a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object in browsers or in a [FormData](https://github.com/form-data/form-data) in Node.js
     *
     * @param params An object to be encoded.
     * @returns The complete [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.
     */
    function encodeFormData(params, forceFormData) {
        // see https://github.com/Esri/arcgis-rest-js/issues/499 for more info.
        var useFormData = requiresFormData(params) || forceFormData;
        var newParams = processParams(params);
        if (useFormData) {
            var formData_1 = new FormData();
            Object.keys(newParams).forEach(function (key) {
                if (typeof Blob !== "undefined" && newParams[key] instanceof Blob) {
                    /* To name the Blob:
                     1. look to an alternate request parameter called 'fileName'
                     2. see if 'name' has been tacked onto the Blob manually
                     3. if all else fails, use the request parameter
                    */
                    var filename = newParams["fileName"] || newParams[key].name || key;
                    formData_1.append(key, newParams[key], filename);
                }
                else {
                    formData_1.append(key, newParams[key]);
                }
            });
            return formData_1;
        }
        else {
            return encodeQueryString(params);
        }
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    // TypeScript 2.1 no longer allows you to extend built in types. See https://github.com/Microsoft/TypeScript/issues/12790#issuecomment-265981442
    // and https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
    //
    // This code is from MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types.
    var ArcGISRequestError = /** @class */ (function () {
        /**
         * Create a new `ArcGISRequestError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options and parameters of the request
         */
        function ArcGISRequestError(message, code, response, url, options) {
            message = message || "UNKNOWN_ERROR";
            code = code || "UNKNOWN_ERROR_CODE";
            this.name = "ArcGISRequestError";
            this.message =
                code === "UNKNOWN_ERROR_CODE" ? message : code + ": " + message;
            this.originalMessage = message;
            this.code = code;
            this.response = response;
            this.url = url;
            this.options = options;
        }
        return ArcGISRequestError;
    }());
    ArcGISRequestError.prototype = Object.create(Error.prototype);
    ArcGISRequestError.prototype.constructor = ArcGISRequestError;

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Method used internally to surface messages to developers.
     */
    function warn(message) {
        if (console && console.warn) {
            console.warn.apply(console, [message]);
        }
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    var NODEJS_DEFAULT_REFERER_HEADER = "@esri/arcgis-rest-js";
    var DEFAULT_ARCGIS_REQUEST_OPTIONS = {
        httpMethod: "POST",
        params: {
            f: "json",
        },
    };
    var ArcGISAuthError = /** @class */ (function (_super) {
        __extends(ArcGISAuthError, _super);
        /**
         * Create a new `ArcGISAuthError`  object.
         *
         * @param message - The error message from the API
         * @param code - The error code from the API
         * @param response - The original response from the API that caused the error
         * @param url - The original url of the request
         * @param options - The original options of the request
         */
        function ArcGISAuthError(message, code, response, url, options) {
            if (message === void 0) { message = "AUTHENTICATION_ERROR"; }
            if (code === void 0) { code = "AUTHENTICATION_ERROR_CODE"; }
            var _this = _super.call(this, message, code, response, url, options) || this;
            _this.name = "ArcGISAuthError";
            _this.message =
                code === "AUTHENTICATION_ERROR_CODE" ? message : code + ": " + message;
            return _this;
        }
        ArcGISAuthError.prototype.retry = function (getSession, retryLimit) {
            var _this = this;
            if (retryLimit === void 0) { retryLimit = 3; }
            var tries = 0;
            var retryRequest = function (resolve, reject) {
                getSession(_this.url, _this.options)
                    .then(function (session) {
                    var newOptions = __assign(__assign({}, _this.options), { authentication: session });
                    tries = tries + 1;
                    return request(_this.url, newOptions);
                })
                    .then(function (response) {
                    resolve(response);
                })
                    .catch(function (e) {
                    if (e.name === "ArcGISAuthError" && tries < retryLimit) {
                        retryRequest(resolve, reject);
                    }
                    else if (e.name === "ArcGISAuthError" && tries >= retryLimit) {
                        reject(_this);
                    }
                    else {
                        reject(e);
                    }
                });
            };
            return new Promise(function (resolve, reject) {
                retryRequest(resolve, reject);
            });
        };
        return ArcGISAuthError;
    }(ArcGISRequestError));
    /**
     * Checks for errors in a JSON response from the ArcGIS REST API. If there are no errors, it will return the `data` passed in. If there is an error, it will throw an `ArcGISRequestError` or `ArcGISAuthError`.
     *
     * @param data The response JSON to check for errors.
     * @param url The url of the original request
     * @param params The parameters of the original request
     * @param options The options of the original request
     * @returns The data that was passed in the `data` parameter
     */
    function checkForErrors(response, url, params, options, originalAuthError) {
        // this is an error message from billing.arcgis.com backend
        if (response.code >= 400) {
            var message = response.message, code = response.code;
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        // error from ArcGIS Online or an ArcGIS Portal or server instance.
        if (response.error) {
            var _a = response.error, message = _a.message, code = _a.code, messageCode = _a.messageCode;
            var errorCode = messageCode || code || "UNKNOWN_ERROR_CODE";
            if (code === 498 ||
                code === 499 ||
                messageCode === "GWM_0003" ||
                (code === 400 && message === "Unable to generate token.")) {
                if (originalAuthError) {
                    throw originalAuthError;
                }
                else {
                    throw new ArcGISAuthError(message, errorCode, response, url, options);
                }
            }
            throw new ArcGISRequestError(message, errorCode, response, url, options);
        }
        // error from a status check
        if (response.status === "failed" || response.status === "failure") {
            var message = void 0;
            var code = "UNKNOWN_ERROR_CODE";
            try {
                message = JSON.parse(response.statusMessage).message;
                code = JSON.parse(response.statusMessage).code;
            }
            catch (e) {
                message = response.statusMessage || response.message;
            }
            throw new ArcGISRequestError(message, code, response, url, options);
        }
        return response;
    }
    /**
     * ```js
     * import { request } from '@esri/arcgis-rest-request';
     * //
     * request('https://www.arcgis.com/sharing/rest')
     *   .then(response) // response.currentVersion === 5.2
     * //
     * request('https://www.arcgis.com/sharing/rest', {
     *   httpMethod: "GET"
     * })
     * //
     * request('https://www.arcgis.com/sharing/rest/search', {
     *   params: { q: 'parks' }
     * })
     *   .then(response) // response.total => 78379
     * ```
     * Generic method for making HTTP requests to ArcGIS REST API endpoints.
     *
     * @param url - The URL of the ArcGIS REST API endpoint.
     * @param requestOptions - Options for the request, including parameters relevant to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function request(url, requestOptions) {
        if (requestOptions === void 0) { requestOptions = { params: { f: "json" } }; }
        var options = __assign(__assign(__assign({ httpMethod: "POST" }, DEFAULT_ARCGIS_REQUEST_OPTIONS), requestOptions), {
            params: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.params), requestOptions.params),
            headers: __assign(__assign({}, DEFAULT_ARCGIS_REQUEST_OPTIONS.headers), requestOptions.headers),
        });
        var missingGlobals = [];
        var recommendedPackages = [];
        // don't check for a global fetch if a custom implementation was passed through
        if (!options.fetch && typeof fetch !== "undefined") {
            options.fetch = fetch.bind(Function("return this")());
        }
        else {
            missingGlobals.push("`fetch`");
            recommendedPackages.push("`node-fetch`");
        }
        if (typeof Promise === "undefined") {
            missingGlobals.push("`Promise`");
            recommendedPackages.push("`es6-promise`");
        }
        if (typeof FormData === "undefined") {
            missingGlobals.push("`FormData`");
            recommendedPackages.push("`isomorphic-form-data`");
        }
        if (!options.fetch ||
            typeof Promise === "undefined" ||
            typeof FormData === "undefined") {
            throw new Error("`arcgis-rest-request` requires a `fetch` implementation and global variables for `Promise` and `FormData` to be present in the global scope. You are missing " + missingGlobals.join(", ") + ". We recommend installing the " + recommendedPackages.join(", ") + " modules at the root of your application to add these to the global scope. See https://bit.ly/2KNwWaJ for more info.");
        }
        var httpMethod = options.httpMethod, authentication = options.authentication, rawResponse = options.rawResponse;
        var params = __assign({ f: "json" }, options.params);
        var originalAuthError = null;
        var fetchOptions = {
            method: httpMethod,
            /* ensures behavior mimics XMLHttpRequest.
            needed to support sending IWA cookies */
            credentials: options.credentials || "same-origin",
        };
        // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header
        // and that request needs to send cookies cross domain
        // so we need to set the credentials to "include"
        if (options.headers &&
            options.headers["X-Esri-Auth-Client-Id"] &&
            url.indexOf("/oauth2/platformSelf") > -1) {
            fetchOptions.credentials = "include";
        }
        return (authentication
            ? authentication.getToken(url, { fetch: options.fetch }).catch(function (err) {
                /**
                 * append original request url and requestOptions
                 * to the error thrown by getToken()
                 * to assist with retrying
                 */
                err.url = url;
                err.options = options;
                /**
                 * if an attempt is made to talk to an unfederated server
                 * first try the request anonymously. if a 'token required'
                 * error is thrown, throw the UNFEDERATED error then.
                 */
                originalAuthError = err;
                return Promise.resolve("");
            })
            : Promise.resolve(""))
            .then(function (token) {
            if (token.length) {
                params.token = token;
            }
            if (authentication && authentication.getDomainCredentials) {
                fetchOptions.credentials = authentication.getDomainCredentials(url);
            }
            // Custom headers to add to request. IRequestOptions.headers with merge over requestHeaders.
            var requestHeaders = {};
            if (fetchOptions.method === "GET") {
                // Prevents token from being passed in query params when hideToken option is used.
                /* istanbul ignore if - window is always defined in a browser. Test case is covered by Jasmine in node test */
                if (params.token &&
                    options.hideToken &&
                    // Sharing API does not support preflight check required by modern browsers https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request
                    typeof window === "undefined") {
                    requestHeaders["X-Esri-Authorization"] = "Bearer " + params.token;
                    delete params.token;
                }
                // encode the parameters into the query string
                var queryParams = encodeQueryString(params);
                // dont append a '?' unless parameters are actually present
                var urlWithQueryString = queryParams === "" ? url : url + "?" + encodeQueryString(params);
                if (
                // This would exceed the maximum length for URLs specified by the consumer and requires POST
                (options.maxUrlLength &&
                    urlWithQueryString.length > options.maxUrlLength) ||
                    // Or if the customer requires the token to be hidden and it has not already been hidden in the header (for browsers)
                    (params.token && options.hideToken)) {
                    // the consumer specified a maximum length for URLs
                    // and this would exceed it, so use post instead
                    fetchOptions.method = "POST";
                    // If the token was already added as a Auth header, add the token back to body with other params instead of header
                    if (token.length && options.hideToken) {
                        params.token = token;
                        // Remove existing header that was added before url query length was checked
                        delete requestHeaders["X-Esri-Authorization"];
                    }
                }
                else {
                    // just use GET
                    url = urlWithQueryString;
                }
            }
            /* updateResources currently requires FormData even when the input parameters dont warrant it.
        https://developers.arcgis.com/rest/users-groups-and-items/update-resources.htm
            see https://github.com/Esri/arcgis-rest-js/pull/500 for more info. */
            var forceFormData = new RegExp("/items/.+/updateResources").test(url);
            if (fetchOptions.method === "POST") {
                fetchOptions.body = encodeFormData(params, forceFormData);
            }
            // Mixin headers from request options
            fetchOptions.headers = __assign(__assign({}, requestHeaders), options.headers);
            /* istanbul ignore next - karma reports coverage on browser tests only */
            if (typeof window === "undefined" && !fetchOptions.headers.referer) {
                fetchOptions.headers.referer = NODEJS_DEFAULT_REFERER_HEADER;
            }
            /* istanbul ignore else blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */
            if (!requiresFormData(params) && !forceFormData) {
                fetchOptions.headers["Content-Type"] =
                    "application/x-www-form-urlencoded";
            }
            return options.fetch(url, fetchOptions);
        })
            .then(function (response) {
            if (!response.ok) {
                // server responded w/ an actual error (404, 500, etc)
                var status_1 = response.status, statusText = response.statusText;
                throw new ArcGISRequestError(statusText, "HTTP " + status_1, response, url, options);
            }
            if (rawResponse) {
                return response;
            }
            switch (params.f) {
                case "json":
                    return response.json();
                case "geojson":
                    return response.json();
                case "html":
                    return response.text();
                case "text":
                    return response.text();
                /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust that isomorphic fetch will do its job */
                default:
                    return response.blob();
            }
        })
            .then(function (data) {
            if ((params.f === "json" || params.f === "geojson") && !rawResponse) {
                var response = checkForErrors(data, url, params, options, originalAuthError);
                if (originalAuthError) {
                    /* If the request was made to an unfederated service that
                    didn't require authentication, add the base url and a dummy token
                    to the list of trusted servers to avoid another federation check
                    in the event of a repeat request */
                    var truncatedUrl = url
                        .toLowerCase()
                        .split(/\/rest(\/admin)?\/services\//)[0];
                    options.authentication.federatedServers[truncatedUrl] = {
                        token: [],
                        // default to 24 hours
                        expires: new Date(Date.now() + 86400 * 1000),
                    };
                    originalAuthError = null;
                }
                return response;
            }
            else {
                return data;
            }
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper for methods with lots of first order request options to pass through as request parameters.
     */
    function appendCustomParams(customOptions, keys, baseOptions) {
        var requestOptionsKeys = [
            "params",
            "httpMethod",
            "rawResponse",
            "authentication",
            "portal",
            "fetch",
            "maxUrlLength",
            "headers"
        ];
        var options = __assign(__assign({ params: {} }, baseOptions), customOptions);
        // merge all keys in customOptions into options.params
        options.params = keys.reduce(function (value, key) {
            if (customOptions[key] || typeof customOptions[key] === "boolean") {
                value[key] = customOptions[key];
            }
            return value;
        }, options.params);
        // now remove all properties in options that don't exist in IRequestOptions
        return requestOptionsKeys.reduce(function (value, key) {
            if (options[key]) {
                value[key] = options[key];
            }
            return value;
        }, {});
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper method to ensure that user supplied urls don't include whitespace or a trailing slash.
     */
    function cleanUrl(url) {
        // Guard so we don't try to trim something that's not a string
        if (typeof url !== "string") {
            return url;
        }
        // trim leading and trailing spaces, but not spaces inside the url
        url = url.trim();
        // remove the trailing slash to the url if one was included
        if (url[url.length - 1] === "/") {
            url = url.slice(0, -1);
        }
        return url;
    }

    /* Copyright (c) 2017 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Helper that returns the appropriate portal url for a given request. `requestOptions.portal` is given
     * precedence over `authentication.portal`. If neither `portal` nor `authentication` is present,
     * `www.arcgis.com/sharing/rest` is returned.
     *
     * @param requestOptions - Request options that may have authentication manager
     * @returns Portal url to be used in API requests
     */
    function getPortalUrl(requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        // use portal in options if specified
        if (requestOptions.portal) {
            return cleanUrl(requestOptions.portal);
        }
        // if auth was passed, use that portal
        if (requestOptions.authentication) {
            // the portal url is already scrubbed in the auth package
            return requestOptions.authentication.portal;
        }
        // default to arcgis.com
        return "https://www.arcgis.com/sharing/rest";
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * Serialize an item and its data into a json format accepted by the Portal API for create and update operations
     *
     * @param item Item to be serialized
     * @returns a formatted json object to be sent to Portal
     */
    function serializeItem(item) {
        // create a clone so we're not messing with the original
        var clone = JSON.parse(JSON.stringify(item));
        // binary data needs POSTed as a `file`
        // JSON object literals should be passed as `text`.
        if (clone.data) {
            (typeof Blob !== "undefined" && item.data instanceof Blob) ||
                // Node.js doesn't implement Blob
                item.data.constructor.name === "ReadStream"
                ? (clone.file = item.data)
                : (clone.text = item.data);
            delete clone.data;
        }
        return clone;
    }
    /**
     * `requestOptions.owner` is given priority, `requestOptions.item.owner` will be checked next. If neither are present, `authentication.getUserName()` will be used instead.
     */
    function determineOwner(requestOptions) {
        if (requestOptions.owner) {
            return Promise.resolve(requestOptions.owner);
        }
        else if (requestOptions.item && requestOptions.item.owner) {
            return Promise.resolve(requestOptions.item.owner);
        }
        else if (requestOptions.authentication &&
            requestOptions.authentication.getUsername) {
            return requestOptions.authentication.getUsername();
        }
        else {
            return Promise.reject(new Error("Could not determine the owner of this item. Pass the `owner`, `item.owner`, or `authentication` option."));
        }
    }

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { updateItem } from "@esri/arcgis-rest-portal";
     * //
     * updateItem({
     *   item: {
     *     id: "3ef",
     *     description: "A three hour tour"
     *   },
     *   authentication
     * })
     *   .then(response)
     * ```
     * Update an Item. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/update-item.htm) for more information.
     *
     * @param requestOptions - Options for the request.
     * @returns A Promise that updates an item.
     */
    function updateItem(requestOptions) {
        return determineOwner(requestOptions).then(function (owner) {
            var url = requestOptions.folderId
                ? getPortalUrl(requestOptions) + "/content/users/" + owner + "/" + requestOptions.folderId + "/items/" + requestOptions.item.id + "/update"
                : getPortalUrl(requestOptions) + "/content/users/" + owner + "/items/" + requestOptions.item.id + "/update";
            // serialize the item into something Portal will accept
            requestOptions.params = __assign(__assign({}, requestOptions.params), serializeItem(requestOptions.item));
            return request(url, requestOptions);
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { getGroup } from "@esri/arcgis-rest-portal";
     * //
     * getGroup("fxb988") // id
     *   .then(response)
     * ```
     * Fetch a group using its id. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group.htm) for more information.
     *
     * @param id - Group Id
     * @param requestOptions  - Options for the request
     * @returns  A Promise that will resolve with the data from the response.
     */
    function getGroup(id, requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id;
        // default to a GET request
        var options = __assign({ httpMethod: "GET" }, requestOptions);
        return request(url, options);
    }
    /**
     * Get the usernames of the admins and members. Does not return actual 'User' objects. Those must be
     * retrieved via separate calls to the User's API.
     * @param id - Group Id
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with arrays of the group admin usernames and the member usernames
     */
    function getGroupUsers(id, requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id + "/users";
        // default to a GET request
        var options = __assign({ httpMethod: "GET" }, requestOptions);
        return request(url, options);
    }
    /**
     * ```js
     * import { searchGroupUsers } from "@esri/arcgis-rest-portal";
     * //
     * searchGroupUsers('abc123')
     *   .then(response)
     * ```
     * Search the users in a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group-users-list.htm) for more information.
     *
     * @param id - The group id
     * @param searchOptions - Options for the request, including paging parameters.
     * @returns A Promise that will resolve with the data from the response.
     */
    function searchGroupUsers(id, searchOptions) {
        var url = getPortalUrl(searchOptions) + "/community/groups/" + id + "/userlist";
        var options = appendCustomParams(searchOptions || {}, ["name", "num", "start", "sortField", "sortOrder", "joined", "memberType"], {
            httpMethod: "GET"
        });
        return request(url, options);
    }

    /* Copyright (c) 2018-2021 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * `SearchQueryBuilder` can be used to construct the `q` param for
     * [`searchItems`](/arcgis-rest-js/api/portal/searchItems#searchItems-search) or
     * [`searchGroups`](/arcgis-rest-js/api/portal/searchGroups#searchGroups-search).
     * By chaining methods, it helps build complex search queries.
     *
     * ```js
     * const startDate = new Date("2020-01-01");
     * const endDate = new Date("2020-09-01");
     * const query = new SearchQueryBuilder()
     *  .match("Patrick")
     *  .in("owner")
     *  .and()
     *  .from(startDate)
     *  .to(endDate)
     *  .in("created")
     *  .and()
     *  .startGroup()
     *    .match("Web Mapping Application")
     *    .in("type")
     *    .or()
     *    .match("Mobile Application")
     *    .in("type")
     *    .or()
     *    .match("Application")
     *    .in("type")
     *  .endGroup()
     *  .and()
     *  .match("Demo App");
     *
     * searchItems(query).then((res) => {
     *   console.log(res.results);
     * });
     * ```
     *
     * Will search for items matching
     * ```
     * "owner: Patrick AND created:[1577836800000 TO 1598918400000] AND (type:"Web Mapping Application" OR type:"Mobile Application" OR type:Application) AND Demo App"
     * ```
     */
    var SearchQueryBuilder = /** @class */ (function () {
        /**
         * @param q An existing query string to start building from.
         */
        function SearchQueryBuilder(q) {
            if (q === void 0) { q = ""; }
            this.termStack = [];
            this.rangeStack = [];
            this.openGroups = 0;
            this.q = q;
        }
        /**
         * Defines strings to search for.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         * ```
         *
         * @param terms strings to search for.
         */
        SearchQueryBuilder.prototype.match = function () {
            var terms = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                terms[_i] = arguments[_i];
            }
            this.termStack = this.termStack.concat(terms);
            return this;
        };
        /**
         * Defines fields to search in. You can pass `"*"` or call this method without arguments to search a default set of fields
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("My Layer")
         *   .in("title")
         * ```
         *
         * @param field The field to search for the previous match in.
         */
        SearchQueryBuilder.prototype.in = function (field) {
            var fn = "`in(" + (field ? "\"" + field + "\"" : "") + ")`";
            if (!this.hasRange && !this.hasTerms) {
                warn(
                // apparently-p-rettier-ignore causes some
                fn + " was called with no call to `match(...)` or `from(...)`/`to(...)`. Your query was not modified.");
                return this;
            }
            if (field && field !== "*") {
                this.q += field + ":";
            }
            return this.commit();
        };
        /**
         * Starts a new search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.startGroup = function () {
            this.commit();
            if (this.openGroups > 0) {
                this.q += " ";
            }
            this.openGroups++;
            this.q += "(";
            return this;
        };
        /**
         * Ends a search group.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .startGroup()
         *     .match("Lakes")
         *     .in("title")
         *   .endGroup()
         *   .or()
         *   .startGroup()
         *     .match("Rivers")
         *     .in("title")
         *   .endGroup()
         * ```
         */
        SearchQueryBuilder.prototype.endGroup = function () {
            if (this.openGroups <= 0) {
                warn("`endGroup(...)` was called without calling `startGroup(...)` first. Your query was not modified.");
                return this;
            }
            this.commit();
            this.openGroups--;
            this.q += ")";
            return this;
        };
        /**
         * Joins two sets of queries with an `AND` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .and()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.and = function () {
            return this.addModifier("and");
        };
        /**
         * Joins two sets of queries with an `OR` clause.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         * ```
         */
        SearchQueryBuilder.prototype.or = function () {
            return this.addModifier("or");
        };
        /**
         * Joins two sets of queries with a `NOT` clause. Another option for filtering results is the [prohibit operator '-'](https://developers.arcgis.com/rest/users-groups-and-items/search-reference.htm#ESRI_SECTION1_5C6C35DB9E4A4F4492C5B937BDA2BF67).
         *
         * ```js
         * // omit results with "Rivers" in their title
         * const query = new SearchQueryBuilder()
         *   .not()
         *   .match("Rivers")
         *   .in("title")
         *
         * // equivalent
         * const query = new SearchQueryBuilder()
         *   .match("Rivers")
         *   .in("-title")
         * ```
         */
        SearchQueryBuilder.prototype.not = function () {
            return this.addModifier("not");
        };
        /**
         * Begins a new range query.
         *
         * ```js
         *
         * const NEWYEARS = new Date("2020-01-01")
         * const TODAY = new Date()
         *
         * const query = new SearchQueryBuilder()
         *   .from(NEWYEARS)
         *   .to(TODAY)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.from = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`from(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\").  Your query was not modified.");
                return this;
            }
            this.rangeStack[0] = term;
            return this;
        };
        /**
         * Ends a range query.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .from(yesterdaysDate)
         *   .to(todaysDate)
         *   .in("created")
         * ```
         */
        SearchQueryBuilder.prototype.to = function (term) {
            if (this.hasTerms) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "`to(...)` is not allowed after `match(...)` try using `.from(...).to(...).in(...)`. Optionally, you may see this because dates are incorrectly formatted. Dates should be a primative Date value, aka a number in milliseconds or Date object, ie new Date(\"2020-01-01\"). Your query was not modified.");
                return this;
            }
            this.rangeStack[1] = term;
            return this;
        };
        /**
         * Boosts the previous term to increase its rank in the results.
         *
         * ```js
         * const query = new SearchQueryBuilder()
         *   .match("Lakes")
         *   .in("title")
         *   .or()
         *   .match("Rivers")
         *   .in("title")
         *   .boost(3)
         * ```
         */
        SearchQueryBuilder.prototype.boost = function (num) {
            this.commit();
            this.q += "^" + num;
            return this;
        };
        /**
         * Returns the current query string. Called internally when the request is made.
         */
        SearchQueryBuilder.prototype.toParam = function () {
            this.commit();
            this.cleanup();
            return this.q;
        };
        /**
         * Returns a new instance of `SearchQueryBuilder` based on the current instance.
         */
        SearchQueryBuilder.prototype.clone = function () {
            this.commit();
            this.cleanup();
            return new SearchQueryBuilder(this.q + "");
        };
        SearchQueryBuilder.prototype.addModifier = function (modifier) {
            if (this.currentModifer) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "You have called `" + this.currentModifer + "()` after `" + modifier + "()`. Your current query was not modified.");
                return this;
            }
            this.commit();
            if (this.q === "" && modifier !== "not") {
                warn("You have called `" + modifier + "()` without calling another method to modify your query first. Try calling `match()` first.");
                return this;
            }
            this.currentModifer = modifier;
            this.q += this.q === "" ? "" : " ";
            this.q += modifier.toUpperCase() + " ";
            return this;
        };
        SearchQueryBuilder.prototype.needsQuotes = function (s) {
            return /\s|:/g.test(s);
        };
        SearchQueryBuilder.prototype.formatTerm = function (term) {
            if (term instanceof Date) {
                return term.getTime();
            }
            if (typeof term === "string" && this.needsQuotes(term)) {
                return "\"" + term + "\"";
            }
            return term;
        };
        SearchQueryBuilder.prototype.commit = function () {
            var _this = this;
            this.currentModifer = undefined;
            if (this.hasRange) {
                this.q += "[" + this.formatTerm(this.rangeStack[0]) + " TO " + this.formatTerm(this.rangeStack[1]) + "]";
                this.rangeStack = [undefined, undefined];
            }
            if (this.hasTerms) {
                this.q += this.termStack
                    .map(function (term) {
                    return _this.formatTerm(term);
                })
                    .join(" ");
                this.termStack = [];
            }
            return this;
        };
        Object.defineProperty(SearchQueryBuilder.prototype, "hasTerms", {
            get: function () {
                return this.termStack.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SearchQueryBuilder.prototype, "hasRange", {
            get: function () {
                return this.rangeStack.length && this.rangeStack[0] && this.rangeStack[1];
            },
            enumerable: false,
            configurable: true
        });
        SearchQueryBuilder.prototype.cleanup = function () {
            // end a group if we have started one
            if (this.openGroups > 0) {
                warn(
                // apparently-p*rettier-ignore causes prettier to strip *all* comments O_o
                "Automatically closing " + this.openGroups + " group(s). You can use `endGroup(...)` to remove this warning.");
                while (this.openGroups > 0) {
                    this.q += ")";
                    this.openGroups--;
                }
            }
            var oldQ = this.q;
            this.q = oldQ.replace(/( AND ?| NOT ?| OR ?)*$/, "");
            if (oldQ !== this.q) {
                warn("`startGroup(...)` was called without calling `endGroup(...)` first. Your query was not modified.");
            }
            // clear empty groups
            this.q = this.q.replace(/(\(\))*/, "");
        };
        return SearchQueryBuilder;
    }());

    /* Copyright (c) 2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    function genericSearch(search, searchType) {
        var options;
        if (typeof search === "string" || search instanceof SearchQueryBuilder) {
            options = {
                httpMethod: "GET",
                params: {
                    q: search,
                },
            };
        }
        else {
            // searchUserAccess has one (knonw) valid value: "groupMember"
            options = appendCustomParams(search, [
                "q",
                "num",
                "start",
                "sortField",
                "sortOrder",
                "searchUserAccess",
                "searchUserName",
                "filter",
                "countFields",
                "countSize",
                "categories",
                "categoryFilters",
            ], {
                httpMethod: "GET",
            });
        }
        var path;
        switch (searchType) {
            case "item":
                path = "/search";
                break;
            case "group":
                path = "/community/groups";
                break;
            case "groupContent":
                // Need to have groupId property to do group contents search,
                // cso filter out all but ISearchGroupContentOptions
                if (typeof search !== "string" &&
                    !(search instanceof SearchQueryBuilder) &&
                    search.groupId) {
                    path = "/content/groups/" + search.groupId + "/search";
                }
                else {
                    return Promise.reject(new Error("you must pass a `groupId` option to `searchGroupContent`"));
                }
                break;
            default:
                // "users"
                path = "/portals/self/users/search";
                break;
        }
        var url = getPortalUrl(options) + path;
        // send the request
        return request(url, options).then(function (r) {
            if (r.nextStart && r.nextStart !== -1) {
                r.nextPage = function () {
                    var newOptions;
                    if (typeof search === "string" ||
                        search instanceof SearchQueryBuilder) {
                        newOptions = {
                            q: search,
                            start: r.nextStart,
                        };
                    }
                    else {
                        newOptions = search;
                        newOptions.start = r.nextStart;
                    }
                    return genericSearch(newOptions, searchType);
                };
            }
            return r;
        });
    }

    /* Copyright (c) 2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    function chunk(array, size) {
        if (array.length === 0) {
            return [];
        }
        var chunks = [];
        for (var i = 0; i < array.length; i += size) {
            chunks.push(array.slice(i, i + size));
        }
        return chunks;
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { addGroupUsers } from "@esri/arcgis-rest-portal";
     * //
     * addGroupUsers({
     *   id: groupId,
     *   users: ["username1", "username2"],
     *   admins: ["username3"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Add users to a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/add-users-to-group.htm) for more information.
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function addGroupUsers(requestOptions) {
        var id = requestOptions.id;
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id + "/addUsers";
        var baseOptions = Object.assign({}, requestOptions, {
            admins: undefined,
            users: undefined
        });
        var batchRequestOptions = __spreadArrays(_prepareRequests("users", requestOptions.users, baseOptions), _prepareRequests("admins", requestOptions.admins, baseOptions));
        var promises = batchRequestOptions.map(function (options) {
            return _sendSafeRequest(url, options);
        });
        return Promise.all(promises).then(_consolidateRequestResults);
    }
    function _prepareRequests(type, usernames, baseOptions) {
        if (!usernames || usernames.length < 1) {
            return [];
        }
        // the ArcGIS REST API only allows to add no more than 25 users per request,
        // see https://developers.arcgis.com/rest/users-groups-and-items/add-users-to-group.htm
        var userChunks = chunk(usernames, 25);
        return userChunks.map(function (users) {
            return _generateRequestOptions(type, users, baseOptions);
        });
    }
    function _generateRequestOptions(type, usernames, baseOptions) {
        var _a, _b;
        return Object.assign({}, baseOptions, (_a = {},
            _a[type] = usernames,
            _a.params = __assign(__assign({}, baseOptions.params), (_b = {}, _b[type] = usernames, _b)),
            _a));
    }
    // this request is safe since the request error will be handled
    function _sendSafeRequest(url, requestOptions) {
        return request(url, requestOptions).catch(function (error) {
            return {
                errors: [error]
            };
        });
    }
    function _consolidateRequestResults(results) {
        var notAdded = results
            .filter(function (result) { return result.notAdded; })
            .reduce(function (collection, result) { return collection.concat(result.notAdded); }, []);
        var errors = results
            .filter(function (result) { return result.errors; })
            .reduce(function (collection, result) { return collection.concat(result.errors); }, []);
        var consolidated = { notAdded: notAdded };
        if (errors.length > 0) {
            consolidated.errors = errors;
        }
        return consolidated;
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { removeGroupUsers } from "@esri/arcgis-rest-portal";
     * //
     * removeGroupUsers({
     *   id: groupId,
     *   users: ["username1", "username2"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Add users to a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/remove-users-from-group.htm) for more information.
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function removeGroupUsers(requestOptions) {
        var id = requestOptions.id, usersToRemove = requestOptions.users;
        var url = getPortalUrl(requestOptions) + "/community/groups/" + id + "/removeUsers";
        var safeSend = function (users) {
            var options = __assign(__assign({}, requestOptions), { users: users, params: { users: users } });
            return request(url, options)
                .catch(function (error) { return ({ errors: [error] }); });
        };
        // the ArcGIS REST API only allows to add no more than 25 users per request,
        // see https://developers.arcgis.com/rest/users-groups-and-items/remove-users-from-group.htm
        var promises = chunk(usersToRemove, 25).map(function (usersChunk) { return safeSend(usersChunk); });
        return Promise.all(promises)
            .then(function (results) {
            var filtered = function (propName) { return results
                .filter(function (result) { return result[propName]; })
                .reduce(function (collection, result) { return collection.concat(result[propName]); }, []); };
            var errors = filtered('errors');
            var consolidated = { notRemoved: filtered('notRemoved') };
            return errors.length ? __assign(__assign({}, consolidated), { errors: errors }) : consolidated;
        });
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { createGroup } from "@esri/arcgis-rest-portal";
     * //
     * createGroup({
     *   group: {
     *     title: "No Homers",
     *     access: "public"
     *   },
     *   authentication
     * })
     *   .then(response)
     * ```
     * Create a new Group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/create-group.htm) for more information.
     *
     * Note: The group name must be unique within the user's organization.
     * @param requestOptions  - Options for the request, including a group object
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function createGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/createGroup";
        requestOptions.params = __assign(__assign({}, requestOptions.params), requestOptions.group);
        return request(url, requestOptions);
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { protectGroup } from '@esri/arcgis-rest-portal';
     * //
     * protectGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Protect a group to avoid accidental deletion. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/protect-group.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function protectGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/protect";
        return request(url, requestOptions);
    }
    /**
     * ```js
     * import { unprotectGroup } from '@esri/arcgis-rest-portal';
     * //
     * unprotectGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Unprotect a Group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/unprotect-group.htm) for more information.
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function unprotectGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/unprotect";
        return request(url, requestOptions);
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { removeGroup } from '@esri/arcgis-rest-portal';
     * //
     * removeGroup({
     *   id: groupId,
     *   authentication
     * })
     *   .then(response)
     * ```
     * Delete a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/delete-group.htm) for more information.
     *
     * @param requestOptions - Options for the request
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function removeGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/delete";
        var options = __assign({}, requestOptions);
        return request(url, options);
    }

    /* Copyright (c) 2018-2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { searchGroups } from "@esri/arcgis-rest-portal";
     * //
     * searchGroups('water')
     *   .then(response) // response.total => 355
     * ```
     * Search a portal for groups. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group-search.htm) for more information.
     *
     * @param search - A string or RequestOptions object to pass through to the endpoint.
     * @returns A Promise that will resolve with the data from the response.
     */
    function searchGroups(search) {
        return genericSearch(search, "group");
    }
    /**
     * ```js
     * import { searchGroupContent } from "@esri/arcgis-rest-portal";
     * //
     * searchGroupContent('water')
     *   .then(response) // response.total => 355
     * ```
     * Search a portal for items in a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group-content-search.htm) for more information.
     *
     * @param options - RequestOptions object amended with search parameters.
     * @returns A Promise that will resolve with the data from the response.
     */
    function searchGroupContent(options) {
        return genericSearch(options, "groupContent");
    }

    /* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
    /**
     * ```js
     * import { updateGroup } from '@esri/arcgis-rest-portal';
     * //
     * updateGroup({
     *   group: { id: "fgr344", title: "new" }
     * })
     *   .then(response)
     * ```
     * Update the properties of a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/update-group.htm) for more information.
     *
     * @param requestOptions - Options for the request, including the group
     * @returns A Promise that will resolve with the success/failure status of the request
     */
    function updateGroup(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.group.id + "/update";
        requestOptions.params = __assign(__assign({}, requestOptions.params), requestOptions.group);
        return request(url, requestOptions);
    }

    /**
     * ```js
     * import { updateUserMemberships } from "@esri/arcgis-rest-portal";
     * //
     * updateUserMemberships({
     *   id: groupId,
     *   admins: ["username3"],
     *   authentication
     * })
     * .then(response);
     * ```
     * Change the user membership levels of existing users in a group
     *
     * @param requestOptions  - Options for the request
     * @returns A Promise
     */
    function updateUserMemberships(requestOptions) {
        var url = getPortalUrl(requestOptions) + "/community/groups/" + requestOptions.id + "/updateUsers";
        var opts = {
            authentication: requestOptions.authentication,
            params: {}
        };
        // add the correct params depending on the type of membership we are changing to
        if (requestOptions.newMemberType === "admin") {
            opts.params.admins = requestOptions.users;
        }
        else {
            opts.params.users = requestOptions.users;
        }
        // make the request
        return request(url, opts);
    }

    /**
     * Does a group with the specified title exist in the users org?
     * @param {String} title Group Title
     * @param {IHubRequestOptions} hubRequestOptions
     */
    function doesGroupExist(title, hubRequestOptions) {
        var orgId = hubRequestOptions.portalSelf.id;
        var searchOpts = {
            q: "(title:\"" + title + "\" accountid:" + orgId + ")",
            authentication: hubRequestOptions.authentication
        };
        return searchGroups(searchOpts)
            .then(function (searchResponse) { return searchResponse.results.length > 0; })
            .catch(function (err) {
            throw Error("Error in team-utils::doesGroupExist " + err);
        });
    }

    /**
     * Given a title, construct a group title that is unique
     * in the user's org.
     * Given a title of "Medical Team", if a group with that title exists
     * this fn will add a number on the end, and increment until
     * an available group title is found - i.e. "Medical Team 3"
     * @param {String} title Group Title to ensure if unique
     * @param {IHubRequestOptions} hubRequestOptions
     * @param {Number} step Number to increment. Defaults to 0
     */
    function getUniqueGroupTitle(title, hubRequestOptions, step) {
        if (step === void 0) { step = 0; }
        var combinedName = title;
        if (step) {
            combinedName = title + " " + step;
        }
        return doesGroupExist(combinedName, hubRequestOptions)
            .then(function (result) {
            if (result) {
                step++;
                return getUniqueGroupTitle(title, hubRequestOptions, step);
            }
            else {
                return combinedName;
            }
        })
            .catch(function (err) {
            throw Error("Error in team-utils::getUniqueGroupTitle " + err);
        });
    }

    /**
     * Portal Priviledges required to set group access to specific levels
     */
    var GROUP_ACCESS_PRIVS = {
        public: ["portal:user:createGroup", "portal:user:shareGroupToPublic"],
        org: ["portal:user:createGroup", "portal:user:shareGroupToOrg"],
        private: ["portal:user:createGroup"]
    };

    /**
     * Returns the allowed group access based on a user's privileges
     * and org level settings
     * @param requestedAccess public || org || private
     * @param user User object w/ privileges array
     * @param portal optional
     */
    function getAllowedGroupAccess(requestedAccess, user, portal) {
        // portal-wide flag takes presidence, and is not sync'd with privs
        var portalWideCanSharePublic = hubCommon.getProp(portal, "canSharePublic") || false;
        // compute what access level the current user can create the group with
        var canCreatePublic = portalWideCanSharePublic &&
            hasAllPrivileges(user, GROUP_ACCESS_PRIVS.public);
        var canCreateOrg = hasAllPrivileges(user, GROUP_ACCESS_PRIVS.org);
        // default to the requested access...
        var result = requestedAccess;
        // if they requested public, but can't make public...
        if (requestedAccess === "public" && !canCreatePublic) {
            // step down to org...
            result = "org";
            // but if they can't do that...
            if (!canCreateOrg) {
                // then do private
                result = "private";
            }
        }
        else {
            // if the requsted access was not public, it's either org or private
            // and if they can't create do org...
            if (requestedAccess === "org" && !canCreateOrg) {
                // must be private
                result = "private";
            }
        }
        return result;
    }

    /**
     * Create a team group. Will ensure the team name is unique in the users org
     * and return the group, with appropriate `.userMembership` attached.
     * @param {Object} user Current User
     * @param {Object} group Group to create
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _createTeamGroup(user, group, hubRequestOptions) {
        group.access = getAllowedGroupAccess(group.access, user, hubRequestOptions.portalSelf);
        return getUniqueGroupTitle(group.title, hubRequestOptions)
            .then(function (uniqueTitle) {
            group.title = uniqueTitle;
            return createGroup({
                group: group,
                authentication: hubRequestOptions.authentication
            });
        })
            .then(function (createResponse) {
            group.id = createResponse.group.id;
            return protectGroup({
                id: group.id,
                authentication: hubRequestOptions.authentication
            });
        })
            .then(function () {
            group.userMembership = {
                username: user.username,
                memberType: "owner",
                applications: 0
            };
            return group;
        })
            .catch(function (ex) {
            throw Error("Error in team-utils::_createTeamGroup " + ex);
        });
    }

    /**
     * Internal: Actually create the team groups
     * @param {String} title Title for the Team group
     * @param {Array} groupTemplates Array of group definitions to create the groups
     * @param {IHubRequestOptions} hubRequestOptions
     * @private
     */
    function _createTeamGroups(title, groupTemplates, translations, hubRequestOptions) {
        // now translate the templates...
        var translatedTemplates = groupTemplates.map(function (tmpl) {
            return _translateTeamTemplate(tmpl, title, translations);
        });
        // now we actually create the groups... obvs async...
        return Promise.all(translatedTemplates.map(function (grpTmpl) {
            return _createTeamGroup(hubRequestOptions.portalSelf.user, grpTmpl, hubRequestOptions);
        }))
            .then(function (groups) {
            // hoist out the id's into a structure that has the groupnameProperty: id
            var props = groups.reduce(function (acc, grp) {
                // assign to the property, if one is specified
                if (grp.config.propertyName) {
                    acc[grp.config.propertyName] = grp.id;
                }
                return acc;
            }, {});
            // remove config node
            groups.forEach(function (g) { return delete g.config; });
            // construct the return the hash...
            // props: the props which can be spread into the item.properties hash..
            // groups: the array of groups that were created
            return {
                props: props,
                groups: groups
            };
        })
            .catch(function (ex) {
            throw Error("Error in team-utils::_createTeamGroups " + ex);
        });
    }

    /**
     * Create a single Team, using the same logic as creating multiple Teams.
     * Also allows a set of custom props to be passed in and applied to the team.
     *
     * This should be used PRIOR to creating Sites/Initiatives.
     * @param {ICreateHubTeamOptions} createHubTeamOptions
     */
    function createHubTeam(opts) {
        var title = opts.title, type = opts.type, props = opts.props, hubRequestOptions = opts.hubRequestOptions;
        // validate that the type is valid...
        if (TEAMTYPES.indexOf(type) === -1) {
            throw new Error("createHubTeam was passed " + type + " which is not a valid type of team. Please send one of: " + TEAMTYPES.join(","));
        }
        // get all the groups the current user can create...
        // filter just the ones that match type...
        var portalSelf = hubRequestOptions.portalSelf;
        var product = hubCommon.getHubProduct(portalSelf);
        var subscriptionType = hubCommon.getSubscriptionType(portalSelf);
        var groupsToCreate = getUserCreatableTeams(portalSelf.user, product, portalSelf.currentVersion, subscriptionType)
            .filter(function (g) {
            return g.config.type === type;
        })
            .map(function (grp) {
            // If props are passed in, spread them over the group object, but only if type === `team`
            if (grp.config.type === "team") {
                return Object.assign({}, grp, props);
            }
            else {
                return grp;
            }
        });
        // use the locale of the current user, or en-us as a fall-back
        var culture = hubCommon.getCulture(hubRequestOptions);
        var locale = hubCommon.convertToWellKnownLocale(culture);
        // Fire that off
        return hubCommon.fetchHubTranslation(locale, hubRequestOptions.portalSelf)
            .then(function (translations) {
            // delegate to createTeamGroups
            return _createTeamGroups(title, groupsToCreate, translations, hubRequestOptions);
        })
            .catch(function (ex) {
            throw Error("Error in team-utils::createHubTeam " + ex);
        });
    }

    /**
     * Create all the groups (aka Teams) required for a Site or Initiative
     * The group names are derived from the Site/Initiative title. Group names
     * must be unique on create, so if necessary we will increment the names
     * after translation. If you need to ADD a Team to an existing Site/Initiative,
     * use the teams-service::addTeams function
     * @param {ICreateHubTeamsOptions} createHubTeamsOptions
     */
    function createHubTeams(opts) {
        var title = opts.title, types = opts.types, hubRequestOptions = opts.hubRequestOptions;
        var product = hubCommon.getHubProduct(hubRequestOptions.portalSelf);
        // get all the groups that this user can create in this environment
        // and filter just the team types requested
        var subscriptionType = hubCommon.getSubscriptionType(hubRequestOptions.portalSelf);
        var teamsToCreate = getUserCreatableTeams(hubRequestOptions.portalSelf.user, product, hubRequestOptions.portalSelf.currentVersion, subscriptionType).filter(function (g) {
            return types.indexOf(g.config.type) > -1;
        });
        // get the culture out of the
        var culture = hubCommon.getCulture(hubRequestOptions);
        var locale = hubCommon.convertToWellKnownLocale(culture);
        // Fire that off
        return hubCommon.fetchHubTranslation(locale, hubRequestOptions.portalSelf)
            .then(function (translations) {
            // create the team groups
            return _createTeamGroups(title, teamsToCreate, translations, hubRequestOptions);
        })
            .catch(function (ex) {
            throw Error("Error in team-utils::createHubTeams " + ex);
        });
    }

    /**
     * Search for teams
     * @param {ISearchOptions} searchRequestOptions
     * @returns {Promise<ISearchResult>}
     * @private
     */
    function _searchTeams(searchRequestOptions) {
        return searchGroups(searchRequestOptions);
    }

    /**
     * Determine if the current user can create a specific type of team
     * @param {Object} user Current User
     * @param {HubTeamType} hubTeamType
     * @param {*} hubRequestOptions
     */
    function canUserCreateTeam(user, hubTeamType, hubRequestOptions) {
        var userGroups = hubCommon.getProp(user, "groups") || [];
        if (userGroups.length > 510) {
            return false;
        }
        else {
            var portalSelf = hubRequestOptions.portalSelf;
            var product = hubCommon.getHubProduct(portalSelf);
            var subscriptionType = hubCommon.getSubscriptionType(portalSelf);
            // get all the groups the user can create in this product...
            return getUserCreatableTeams(user, product, portalSelf.currentVersion, subscriptionType).some(function (t) { return t.config.type === hubTeamType; });
        }
    }

    /**
     * Return a map from the team names to the property names
     * @param {string} product Product Name (basic, premium, enterprise)
     */
    function getTeamPropertiesMapForProduct(product) {
        // basic and enterprise, it's just the content group
        var map = {
            content: "contentGroupId",
            core: "collaborationGroupId"
        };
        // premium, we add core and followers
        if (product === "premium") {
            map.followers = "followersGroupId";
        }
        return map;
    }

    // TODO: at next breaking change remove portalApiVersion param
    /**
     * Given a product, return the groups templates that are available
     * @param {string} product Product name portal | basic | premium
     */
    function getTeamsAvailableInProduct(product, portalApiVersion // DEPRECATED
    ) {
        /* tslint:disable no-console */
        console.warn("Hub.js::getTeamsAvailableInProduct Deprecation warning portalApiVersion will be removed at v10.0.0");
        /* tslint:enable no-console */
        var teams = WELLKNOWNTEAMS;
        var filterFn = function (tmpl) {
            return tmpl.config.availableIn.indexOf(product) > -1;
        };
        return hubCommon.cloneObject(teams).filter(filterFn);
    }

    /**
     * Get the template for a team. This should be used sparingly,
     * usually when you need some of the default properties of the
     * group, but in a context outside of the normal team-service functions.
     * @param {string} team core \ content | followers | team
     * @param {string} product basic | premium | portal
     * @param {string} portalApiVersion portal version
     */
    function getTeamTemplate(type, product, portalApiVersion) {
        return getTeamsAvailableInProduct(product).find(function (t) {
            return t.config.type === type;
        });
    }

    /**
     * Get the types of teams that can be created given the product
     * @param {string} product Product name portal | basic | premium
     */
    function getTeamTypesAvailableInProduct(product, portalApiVersion) {
        return getTeamsAvailableInProduct(product).map(function (team) {
            return team.config.type;
        });
    }

    function getTeamsForProduct(product) {
        var teams = ["content", "core"];
        if (product === "premium") {
            teams.push("followers");
        }
        return teams;
    }

    /**
     * Enum of the types of teams mapped to their item properties
     */
    var TYPEMAP = {
        core: "collaborationGroupId",
        content: "contentGroupId",
        followers: "followersGroupId"
    };

    /**
     * Get a team by id
     * @param {string} id group id
     * @param {IRequestOptions} hubRequestOptions
     * @returns {Promise<IGroup>}
     */
    function getTeamById(id, hubRequestOptions) {
        return getGroup(id, hubRequestOptions);
    }

    /**
     * Get the users(usernames ONLY) that are members of the Group that backs the Team
     * @param {string} id group id
     * @param {IRequestOptions} hubRequestOptions
     * @returns {Promise<IGroupUsersResult>}
     */
    function getTeamMembers(id, hubRequestOptions) {
        return getGroupUsers(id, hubRequestOptions);
    }

    /**
     * Get the users(actual USER OBJECTS) that are members of the Group that backs the Team
     * @param {string} id group id
     * @param {ISearchGroupUsersOptions} searchOptions
     * @returns {Promise<ISearchGroupUsersResult>}
     */
    function searchTeamMembers(id, searchOptions) {
        return searchGroupUsers(id, searchOptions);
    }

    /**
     * Get the content of a team
     * @param {ISearchGroupContentOptions} searchOptions
     * @returns {Promise<ISearchResult<IItem>>}
     */
    function searchTeamContent(searchOptions) {
        return searchGroupContent(searchOptions);
    }

    /**
     * Checks if user has access to edit a team
     * @param {IGroup} group
     * @param {IUser} user
     * @returns {boolean}
     */
    function canEditTeam(group, user) {
        var _a, _b;
        var memberType = (_a = group.userMembership) === null || _a === void 0 ? void 0 : _a.memberType;
        var userName = (_b = group.userMembership) === null || _b === void 0 ? void 0 : _b.username;
        return (userName === user.username &&
            (memberType === "owner" || memberType === "admin"));
    }

    /**
     * @private
     * Returns an empty instance of the addorinviteresponse object.
     * We are using this because if you leave out any of the props
     * from the final object and you are concatting together arrays you can concat
     * an undeifined inside an array which will throw off array lengths.
     *
     * @export
     * @return {IAddOrInviteResponse}
     */
    function handleNoUsers(context, userType, shouldEmail) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, {
                        notAdded: [],
                        notEmailed: [],
                        notInvited: [],
                        users: [],
                        errors: [],
                    }];
            });
        });
    }

    /**
     * @private
     * Auto add N users to a single group, with users added as admins of that group
     *
     * @export
     * @param {string} id Group ID
     * @param {IUser[]} admins array of users to add to group as admin
     * @param {IAuthenticationManager} authentication authentication manager
     * @return {IAddGroupUsersResult} Result of the transaction (null if no users are passed in)
     */
    function autoAddUsersAsAdmins(id, admins, authentication) {
        var response = Promise.resolve(null);
        if (admins.length) {
            var args = {
                id: id,
                admins: admins.map(function (a) { return a.username; }),
                authentication: authentication,
            };
            response = addGroupUsers(args);
        }
        return response;
    }

    /**
     * @private
     * Governs the logic for emailing N users. It acts under the assumption
     * that all the 'community' users are the ones being emailed (this is due to platform rules we conform to)
     * Function is called upstream depending on if an email object is attached to the context.
     * Email object contains its own auth as it'll require the community admin to send the email itself.
     * An individual email call goes out for each user due to how the response of multiple users in a single call works.
     *
     * @export
     * @param {IAddOrInviteContext} context context object
     * @return {IAddOrInviteResponse} response object
     */
    function processEmailUsers(context) {
        return __awaiter(this, void 0, void 0, function () {
            var users, notEmailed, errors, _i, users_1, user, emailResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        users = hubCommon.getProp(context, "community");
                        notEmailed = [];
                        errors = [];
                        _i = 0, users_1 = users;
                        _a.label = 1;
                    case 1:
                        if (!(_i < users_1.length)) return [3 /*break*/, 4];
                        user = users_1[_i];
                        return [4 /*yield*/, hubCommon.emailOrgUsers([user], hubCommon.getProp(context, "email.message"), hubCommon.getProp(context, "email.auth"), true)];
                    case 2:
                        emailResponse = _a.sent();
                        // If it's just a failed email
                        // then add username to notEmailed array
                        if (!emailResponse.success) {
                            notEmailed.push(user.username);
                            // If there was a legit error
                            // Then only the error returns from
                            // online. Add error AND include username in notEmailed array.
                            if (emailResponse.errors) {
                                errors = errors.concat(emailResponse.errors);
                            }
                        }
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: 
                    // if you leave out any of the props
                    // from the final object and you are concatting together arrays you can concat
                    // an undeifined inside an array which will throw off array lengths.
                    return [2 /*return*/, {
                            users: users.map(function (u) { return u.username; }),
                            notEmailed: notEmailed,
                            errors: errors,
                            notInvited: [],
                            notAdded: [],
                        }];
                }
            });
        });
    }

    /**
     * @private
     * Governs logic for automatically adding N users to a group.
     * Users are added as either a regular user OR as an administrator of the group
     * depending on the addUserAsGroupAdmin prop on the IAddOrInviteContext.
     * If there is an email object on the IAddOrInviteContext, then email notifications are sent.
     *
     * @export
     * @param {IAddOrInviteContext} context context object
     * @param {string} userType what type of user is it: org | world | community
     * @param {boolean} [shouldEmail=false] should the user be emailed?
     * @return {IAddOrInviteResponse} response object
     */
    function processAutoAddUsers(context, userType, shouldEmail) {
        if (shouldEmail === void 0) { shouldEmail = false; }
        return __awaiter(this, void 0, void 0, function () {
            var users, autoAddResponse, emailResponse, notAdded, errors, addUserAsGroupAdmin;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        users = hubCommon.getProp(context, userType);
                        notAdded = [];
                        errors = [];
                        addUserAsGroupAdmin = context.addUserAsGroupAdmin;
                        if (!addUserAsGroupAdmin) return [3 /*break*/, 2];
                        return [4 /*yield*/, autoAddUsersAsAdmins(hubCommon.getProp(context, "groupId"), users, hubCommon.getProp(context, "primaryRO"))];
                    case 1:
                        // if is core team we elevate user to admin
                        autoAddResponse = _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, hubCommon.autoAddUsers(hubCommon.getProp(context, "groupId"), users, hubCommon.getProp(context, "primaryRO"))];
                    case 3:
                        // if not then we are just auto adding them
                        autoAddResponse = _a.sent();
                        _a.label = 4;
                    case 4:
                        // handle notAdded users
                        if (autoAddResponse.notAdded) {
                            notAdded = notAdded.concat(autoAddResponse.notAdded);
                        }
                        // Merge errors into empty array
                        if (autoAddResponse.errors) {
                            errors = errors.concat(autoAddResponse.errors);
                        }
                        if (!shouldEmail) return [3 /*break*/, 6];
                        return [4 /*yield*/, processEmailUsers(context)];
                    case 5:
                        emailResponse = _a.sent();
                        // merge errors in to overall errors array to keep things flat
                        if (emailResponse.errors && emailResponse.errors.length > 0) {
                            errors = errors.concat(emailResponse.errors);
                        }
                        _a.label = 6;
                    case 6: 
                    // if you leave out any of the props
                    // from the final object and you are concatting together arrays you can concat
                    // an undeifined inside an array which will throw off array lengths.
                    return [2 /*return*/, {
                            users: users.map(function (u) { return u.username; }),
                            notAdded: notAdded,
                            errors: errors,
                            notEmailed: (emailResponse === null || emailResponse === void 0 ? void 0 : emailResponse.notEmailed) || [],
                            notInvited: [],
                        }];
                }
            });
        });
    }

    /**
     * @private
     * Governs the logic for inviting N users to a single group.
     * An individual invite call goes out for each user and the results are consolidated.
     * See comment in function about the for...of loop which explains reasoning.
     *
     * @export
     * @param {IAddOrInviteContext} context context object
     * @param {string} userType what type of user is it: org | world | community
     * @return {IAddOrInviteResponse} response object
     */
    function processInviteUsers(context, userType) {
        return __awaiter(this, void 0, void 0, function () {
            var users, notInvited, errors, addUserAsGroupAdmin, _i, users_1, user, inviteResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        users = hubCommon.getProp(context, userType);
                        notInvited = [];
                        errors = [];
                        addUserAsGroupAdmin = context.addUserAsGroupAdmin;
                        _i = 0, users_1 = users;
                        _a.label = 1;
                    case 1:
                        if (!(_i < users_1.length)) return [3 /*break*/, 4];
                        user = users_1[_i];
                        return [4 /*yield*/, hubCommon.inviteUsers(hubCommon.getProp(context, "groupId"), [user], hubCommon.getProp(context, "primaryRO"), 20160, // timeout
                            addUserAsGroupAdmin ? "group_admin" : "group_member" // if we are in a core team we want to invite them as a group admin, otherwise a group member
                            )];
                    case 2:
                        inviteResponse = _a.sent();
                        // If it's just a failed invite then
                        // add username to notInvited array
                        if (!inviteResponse.success) {
                            notInvited.push(user.username);
                            // If there was a legit error
                            // Then only the error returns from
                            // online. Add error AND include username in notInvited array.
                            if (inviteResponse.errors) {
                                errors = errors.concat(inviteResponse.errors);
                            }
                        }
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: 
                    // if you leave out any of the props
                    // from the final object and you are concatting together arrays you can concat
                    // an undeifined inside an array which will throw off array lengths.
                    return [2 /*return*/, {
                            users: users.map(function (u) { return u.username; }),
                            notInvited: notInvited,
                            errors: errors,
                            notEmailed: [],
                            notAdded: [],
                        }];
                }
            });
        });
    }

    /**
     * @private
     * Handles add/invite logic for community users
     * It returns either an empty instance of the addOrInviteResponse
     * object, or either ther esponse from processing auto adding
     * users or inviting users. If an email has been passed in it also notifies
     * processAutoAddUsers that emails should be sent.
     *
     * @export
     * @param {IAddOrInviteContext} context context object
     * @return {IAddOrInviteResponse} response object
     */
    function addOrInviteCommunityUsers(context) {
        return __awaiter(this, void 0, void 0, function () {
            var fnToCall, shouldEmail;
            return __generator(this, function (_a) {
                fnToCall = handleNoUsers;
                shouldEmail = false;
                // If community users were passed in...
                if (context.community && context.community.length > 0) {
                    // Default to either autoAdd or invite based on canAutoAddUser.
                    fnToCall = context.canAutoAddUser
                        ? processAutoAddUsers
                        : processInviteUsers;
                    // If we have an email object
                    // Then we will auto add...
                    // But whether or not we email is still in question
                    if (context.email) {
                        // If the email object has the groupId property...
                        if (context.email.hasOwnProperty("groupId")) {
                            // If the email objects groupId property is the same as the current groupId in context...
                            // (This function is part of a flow that could work for N groupIds)
                            if (context.email.groupId === context.groupId) {
                                // Then we auto add and send email
                                fnToCall = processAutoAddUsers;
                                shouldEmail = true;
                            } // ELSE if the groupId's do NOT match, we will fall back
                            // To autoAdd or invite as per line 32.
                            // We are doing the above logic (lines 43 - 47) because
                            // We wish to add users to core teams, followers, and content teams
                            // but only to email the core team.
                        }
                        else {
                            // If it does not have a groupId at all then we will autoAdd and email.
                            fnToCall = processAutoAddUsers;
                            shouldEmail = true;
                        }
                    }
                }
                // Return/call the function
                return [2 /*return*/, fnToCall(context, "community", shouldEmail)];
            });
        });
    }

    /**
     * @private
     * Handles add/invite logic for Org users
     * It returns either an empty instance of the addOrInviteResponse
     * object, or either ther esponse from processing auto adding a users or inviting a user
     *
     * @export
     * @param {IAddOrInviteContext} context context object
     * @return {IAddOrInviteResponse} response object
     */
    function addOrInviteOrgUsers(context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // If there are no org users return handling no users
                if (!context.org || context.org.length === 0) {
                    // we return an empty object because
                    // if you leave out any of the props
                    // from the final object and you are concatting together arrays you can concat
                    // an undeifined inside an array which will throw off array lengths.
                    return [2 /*return*/, handleNoUsers()];
                }
                // for org user if you have assignUsers then auto add the user
                // if not then invite the user
                return [2 /*return*/, context.canAutoAddUser
                        ? processAutoAddUsers(context, "org")
                        : processInviteUsers(context, "org")];
            });
        });
    }

    /**
     * @private
     * Handles add/invite logic for world users
     * It either returns an empty instance of the add/invite response
     * object, or a populated version from processInviteUsers
     *
     * @export
     * @param {IAddOrInviteContext} context Context object
     * @return {IAddOrInviteResponse} Response object
     */
    function addOrInviteWorldUsers(context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // If there are no world users return handling no users
                if (!context.world || context.world.length === 0) {
                    // we return an empty object because
                    // if you leave out any of the props
                    // from the final object and you are concatting together arrays you can concat
                    // an undeifined inside an array which will throw off array lengths.
                    return [2 /*return*/, handleNoUsers()];
                }
                // process invite
                return [2 /*return*/, processInviteUsers(context, "world")];
            });
        });
    }

    /**
     * @private
     * Handles add/invite logic for partnered org users.
     * It returns either an empty instance of the addOrInviteResponse
     * object, or their response from inviting users.
     *
     * @export
     * @param {IAddOrInviteContext} context context object
     * @return {IAddOrInviteResponse} response object
     */
    function addOrInvitePartneredUsers(context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // If there are no org users return handling no users
                if (!context.partnered || context.partnered.length === 0) {
                    // we return an empty object because
                    // if you leave out any of the props
                    // from the final object and you are concatting together arrays you can concat
                    // an undeifined inside an array which will throw off array lengths.
                    return [2 /*return*/, handleNoUsers()];
                }
                // process invite
                return [2 /*return*/, processInviteUsers(context, "partnered")];
            });
        });
    }

    /**
     * @private
     * Handles add/invite logic for collaboration coordinators inside partnered orgs.
     * This is intentionally split out from the invitation of partnered org normal members,
     * because the two types of partnered org usres (regular and collaboration coordinator)
     * always come from the same 'bucket', however have distinctly different add paths Invite vs auto add.
     * It returns either an empty instance of the addOrInviteResponse
     * object, or their response from auto adding users.
     *
     * @export
     * @param {IAddOrInviteContext} context context object
     * @return {IAddOrInviteResponse} response object
     */
    function addOrInviteCollaborationCoordinators(context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // If there are no org users return handling no users
                if (!context.collaborationCoordinator ||
                    context.collaborationCoordinator.length === 0) {
                    // we return an empty object because
                    // if you leave out any of the props
                    // from the final object and you are concatting together arrays you can concat
                    // an undeifined inside an array which will throw off array lengths.
                    return [2 /*return*/, handleNoUsers()];
                }
                return [2 /*return*/, processAutoAddUsers(context, "collaborationCoordinator")];
            });
        });
    }

    /**
     * @private
     * Takes users array and sorts them into an object by the type of user they are
     * based on the orgType prop (world|org|community)
     *
     * @export
     * @param {IUserWithOrgType[]} users array of users
     * @return {IUserOrgRelationship} Object of users sorted by type (world, org, community)
     */
    function groupUsersByOrgRelationship(users) {
        return users.reduce(function (acc, user) {
            // keyof needed to make bracket notation work without TS throwing a wobbly.
            var orgType = user.orgType;
            acc[orgType].push(user);
            return acc;
        }, {
            world: [],
            org: [],
            community: [],
            partnered: [],
            collaborationCoordinator: [],
        });
    }

    /**
     * Takes array of group ids, if it is a core team, and teams status
     * and returns array of groups
     *
     * @param {array} groupIds Array of group ids
     * @param {boolean} isCoreTeam is this a core team?
     * @param {ITeamsStatus} teamsStatus status of main teams associated with site (core, content, followers)
     */
    function teamsToAddUsersTo(groupIds, isCoreTeam, teamsStatus) {
        // If it's a core team && we have the teamsStatus
        if (isCoreTeam && teamsStatus) {
            // Array<keyof etc is needed due to bracket notation to prevent TS from throwing a wobbly
            ["content", "followers"].forEach(function (teamProp) {
                if (teamsStatus[teamProp] && teamsStatus[teamProp].isOk) {
                    groupIds.push(teamsStatus[teamProp].id);
                }
            });
        }
        return groupIds;
    }

    /**
     * Given an item, a teamType and a user, return the status
     * of the team ('ok', 'missing', 'broken', 'fixable' ), along
     * with specific details:
     * id: id of the group
     * isMissing: was the group simply never created?
     * isBroken: true if the item has an id for the group, but the group can not be found
     * canFix: true if user can create the group
     * If a team that a route depends on returns `isBroken` the route should redirect
     * to /teams/repair, which will do a full inspection, list things that are broken
     * and then conduct any repairs that can be done. It will list the issues, with
     * the intent of training customers to NOT mess with Team groups in AGO.
     * Once repairs are complete, the user will click a button to return to the route they
     * we attempting to enter before this diversion.
     *
     * @export
     * @param {IItem} item Site or Initiative ITEM (not model)
     * @param {("core" | "content" | "followers")} teamType Type of team to check for
     * @param {IUser} user User Object
     * @param {IHubRequestOptions} ro Auth
     * @return {*}  {Promise<ITeamStatus>}
     */
    function getTeamStatus(item, teamType, user, ro) {
        return __awaiter(this, void 0, void 0, function () {
            var result, id, group, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        result = {
                            teamType: teamType,
                            id: null,
                            isOk: false,
                            isMissing: true,
                            isBroken: false,
                            canFix: false,
                            isMember: false,
                        };
                        id = hubCommon.getProp(hubCommon.getProp(item, "properties"), TYPEMAP[teamType]);
                        if (!id) return [3 /*break*/, 9];
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, , 8]);
                        return [4 /*yield*/, getTeamById(id, ro)];
                    case 2:
                        group = _d.sent();
                        if (!group) return [3 /*break*/, 3];
                        result.id = id;
                        result.isOk = true;
                        result.isMissing = false;
                        return [3 /*break*/, 5];
                    case 3:
                        // If it doesn't, then check to see if user can Create team
                        result.id = id;
                        result.isBroken = true;
                        _a = result;
                        return [4 /*yield*/, canUserCreateTeam(user, teamType, ro)];
                    case 4:
                        _a.canFix = _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        _d.sent();
                        // If the search errors then check if user can create team
                        result.id = id;
                        result.isBroken = true;
                        _b = result;
                        return [4 /*yield*/, canUserCreateTeam(user, teamType, ro)];
                    case 7:
                        _b.canFix = _d.sent();
                        return [3 /*break*/, 8];
                    case 8: return [3 /*break*/, 11];
                    case 9:
                        // If there is not an id then check if the user can create the team
                        _c = result;
                        return [4 /*yield*/, canUserCreateTeam(user, teamType, ro)];
                    case 10:
                        // If there is not an id then check if the user can create the team
                        _c.canFix = _d.sent();
                        _d.label = 11;
                    case 11: return [2 /*return*/, result];
                }
            });
        });
    }

    /**
     * Add or invite N users to a single team
     * Org|community|world logic flows are run even if there are no users applicable for that particular path.
     * Results from each path are consolidated and surfaced in the return object as failures and errors are of
     * more importance than successes.
     *
     * @export
     * @param {string} groupId Group we are adding users to
     * @param {IUserWithOrgType[]} users array of users to add
     * @param {IAuthenticationManager} primaryRO primary requestOptions
     * @param {boolean} canAutoAddUser Can we automatically add a user to the team?
     * @param {boolean} addUserAsGroupAdmin Should the user be added as a group administrator
     * @param {IAddOrInviteEmail} email Email object
     * @return {IAddOrInviteToTeamResult} Result object
     */
    function addOrInviteUsersToTeam(groupId, users, primaryRO, canAutoAddUser, addUserAsGroupAdmin, email) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedUsers, inputParams, context, result, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        parsedUsers = groupUsersByOrgRelationship(users);
                        inputParams = {
                            groupId: groupId,
                            primaryRO: primaryRO,
                            allUsers: users,
                            canAutoAddUser: canAutoAddUser,
                            addUserAsGroupAdmin: addUserAsGroupAdmin,
                            email: email,
                        };
                        context = Object.assign(inputParams, parsedUsers);
                        _a = {};
                        return [4 /*yield*/, addOrInviteCommunityUsers(context)];
                    case 1:
                        _a.community = _b.sent();
                        return [4 /*yield*/, addOrInviteOrgUsers(context)];
                    case 2:
                        _a.org = _b.sent();
                        return [4 /*yield*/, addOrInviteWorldUsers(context)];
                    case 3:
                        _a.world = _b.sent();
                        return [4 /*yield*/, addOrInvitePartneredUsers(context)];
                    case 4:
                        _a.partnered = _b.sent();
                        return [4 /*yield*/, addOrInviteCollaborationCoordinators(context)];
                    case 5:
                        result = (_a.collaborationCoordinator = _b.sent(),
                            _a.notAdded = [],
                            _a.notInvited = [],
                            _a.notEmailed = [],
                            _a.errors = [],
                            _a.groupId = groupId,
                            _a);
                        // Bring not added / invited / emailed / errors up to the top level
                        result.notAdded = __spreadArrays(result.community.notAdded, result.org.notAdded, result.world.notAdded);
                        result.notInvited = __spreadArrays(result.community.notInvited, result.org.notInvited, result.world.notInvited);
                        result.notEmailed = __spreadArrays(result.community.notEmailed, result.org.notEmailed, result.world.notEmailed);
                        result.errors = __spreadArrays(result.community.errors, result.org.errors, result.world.errors);
                        return [2 /*return*/, result];
                }
            });
        });
    }

    /**
     * addOrInviteUsersToTeams adds/invites N users to N teams
     * Initial entry point function for add/invite members flow
     * when dealing with multiple teams.
     * Responses from each group are then consolidated into the final returned object.
     *
     * @export
     * @param {string[]} groupIds array of groups we are adding users to
     * @param {IUserWithOrgType[]} users array of users to add to those teams
     * @param {IAuthenticationManager} primaryRO primary requestOptions
     * @param {boolean} [canAutoAddUser=false] Can we automatically add a user to the team?
     * @param {boolean} [addUserAsGroupAdmin=false] Can the user be added to a team as an administrator of that team?
     * @param {IAddOrInviteEmail} [email] Email object contains auth for the email && the email object itself
     * @return {*}  {Promise<{
     *   notAdded: string[];
     *   notInvited: string[];
     *   notEmailed: string[];
     *   errors: ArcGISRequestError[];
     *   responses: IAddOrInviteToTeamResult[];
     * }>} Results object
     */
    function addOrInviteUsersToTeams(groupIds, users, primaryRO, canAutoAddUser, addUserAsGroupAdmin, email) {
        if (canAutoAddUser === void 0) { canAutoAddUser = false; }
        if (addUserAsGroupAdmin === void 0) { addUserAsGroupAdmin = false; }
        return __awaiter(this, void 0, void 0, function () {
            var notAdded, notInvited, notEmailed, errors, responses, _i, groupIds_1, groupId, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        notAdded = [];
                        notInvited = [];
                        notEmailed = [];
                        errors = [];
                        responses = [];
                        _i = 0, groupIds_1 = groupIds;
                        _a.label = 1;
                    case 1:
                        if (!(_i < groupIds_1.length)) return [3 /*break*/, 4];
                        groupId = groupIds_1[_i];
                        return [4 /*yield*/, addOrInviteUsersToTeam(groupId, users, primaryRO, canAutoAddUser, addUserAsGroupAdmin, email)];
                    case 2:
                        result = _a.sent();
                        // attach each groups results
                        responses.push(result);
                        // surface results to the top of the stack...
                        notAdded = notAdded.concat(result.notAdded);
                        errors = errors.concat(result.errors);
                        notInvited = notInvited.concat(result.notInvited);
                        notEmailed = notEmailed.concat(result.notEmailed);
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: 
                    // Return built up result object.
                    return [2 /*return*/, {
                            notAdded: notAdded,
                            notInvited: notInvited,
                            notEmailed: notEmailed,
                            errors: errors,
                            responses: responses,
                        }];
                }
            });
        });
    }

    /**
     * Removes a Team from N hub models.
     * First, if passed deleteTeam, it will delete the team
     * Then it iterates over an array of IModels and removes the given team ID from their teams array
     *
     * @export
     * @param {string} teamId Team ID of the team we are removing
     * @param {IModel[]} models Array of IModels
     * @param {UserSession} authentication Auth
     * @return {*}  {Promise<IUpdateItemResponse[]>}
     */
    function removeTeamFromItems(teamId, models, authentication) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // Iterate over all items...
                return [2 /*return*/, Promise.all(models.map(function (model) {
                        // clone the item before modifying
                        var clonedModel = hubCommon.cloneObject(model);
                        // remove the id from the item.properties.teams array
                        clonedModel.item.properties.teams = hubCommon.without(clonedModel.item.properties.teams, teamId);
                        // Check if the user has access to edit the item. itemControl is only present when the item is directly fetched
                        // 
                        return clonedModel.item.itemControl === "admin" || clonedModel.item.itemControl === "update"
                            // If yes, then update the item
                            ? updateItem({
                                item: clonedModel.item,
                                authentication: authentication,
                            })
                            // Otherwise return a 'fail' state for that item specifically
                            : { id: clonedModel.item.id, success: false };
                    }))];
            });
        });
    }

    /**
     * removeTeam unprotects a group, then deletes it
     *
     * @export
     * @param {string} id Team Id
     * @param {UserSession} authentication authentication
     * @return {*}  {Promise<{groupId: string; success: boolean}>}
     */
    function removeTeam(id, authentication) {
        return __awaiter(this, void 0, void 0, function () {
            var unprotectResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, unprotectGroup({ id: id, authentication: authentication })];
                    case 1:
                        unprotectResult = _a.sent();
                        // If that succeeded...
                        return [2 /*return*/, unprotectResult.success
                                // Remove it.
                                ? removeGroup({ id: id, authentication: authentication })
                                // Otherwise return a fail state
                                : { groupId: id, success: false }];
                }
            });
        });
    }

    /**
     * Remove N users from team. Acts as a wrapper around removeGroupUsers from arcgis-rest-portal
     *
     * @export
     * @param {string} id Group Id
     * @param {string[]} users Array of usernames to remove
     * @param {IAuthenticationManager} authentication auth
     * @return {*}  {Promise<IRemoveGroupUsersResult>}
     */
    function removeUsersFromTeam(id, users, authentication) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, removeGroupUsers({
                        id: id,
                        users: users,
                        authentication: authentication,
                    })];
            });
        });
    }

    /**
     * Removes N users from N teams. Calls removeUsersFromTeam on each of the N teams
     *
     * @export
     * @param {string[]} teamIds Array of team ids
     * @param {string[]} usernames Array of usernames to remove
     * @param {IAuthenticationManager} ro Auth
     * @return {*}  {Promise<IRemoveGroupUsersResult[]>}
     */
    function removeUsersFromTeams(teamIds, usernames, ro) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(teamIds.map(function (id) { return removeUsersFromTeam(id, usernames, ro); }))];
            });
        });
    }

    /**
     * Updates a group. Wrapper around updateGroup from arcgis-rest-portal
     *
     * @export
     * @param {IGroup} group Group object that's being updated
     * @param {IAuthenticationManager} authentication Auth
     * @return {*}  {Promise<{ success: boolean; groupId: string }>}
     */
    function updateTeam(group, authentication) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, updateGroup({ group: group, authentication: authentication })];
            });
        });
    }

    /**
     * Updates users membership to admin or member, acts as a wrapper for updateUserMemberships from arcgis-rest-portal
     *
     * @export
     * @param {string} id Group id that the members belong to
     * @param {string[]} users Array of usernames to update membership level on
     * @param {("member" | "admin")} newMemberType The type of user to update the users to
     * @param {UserSession} authentication authentication
     * @return {*}  {Promise<IUpdateGroupUsersResult>}
     */
    function updateUserMembership(id, users, newMemberType, authentication) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, updateUserMemberships({
                        id: id,
                        users: users,
                        newMemberType: newMemberType,
                        authentication: authentication,
                    })];
            });
        });
    }

    exports.GROUP_ACCESS_PRIVS = GROUP_ACCESS_PRIVS;
    exports.TEAMTYPES = TEAMTYPES;
    exports.TYPEMAP = TYPEMAP;
    exports._createTeamGroup = _createTeamGroup;
    exports._createTeamGroups = _createTeamGroups;
    exports._searchTeams = _searchTeams;
    exports._translateTeamTemplate = _translateTeamTemplate;
    exports.addOrInviteCollaborationCoordinators = addOrInviteCollaborationCoordinators;
    exports.addOrInviteCommunityUsers = addOrInviteCommunityUsers;
    exports.addOrInviteOrgUsers = addOrInviteOrgUsers;
    exports.addOrInvitePartneredUsers = addOrInvitePartneredUsers;
    exports.addOrInviteUsersToTeam = addOrInviteUsersToTeam;
    exports.addOrInviteUsersToTeams = addOrInviteUsersToTeams;
    exports.addOrInviteWorldUsers = addOrInviteWorldUsers;
    exports.addUsersToTeam = addUsersToTeam;
    exports.autoAddUsersAsAdmins = autoAddUsersAsAdmins;
    exports.canEditTeam = canEditTeam;
    exports.canUserCreateTeam = canUserCreateTeam;
    exports.canUserCreateTeamInProduct = canUserCreateTeamInProduct;
    exports.createHubTeam = createHubTeam;
    exports.createHubTeams = createHubTeams;
    exports.doesGroupExist = doesGroupExist;
    exports.getAllowedGroupAccess = getAllowedGroupAccess;
    exports.getTeamById = getTeamById;
    exports.getTeamMembers = getTeamMembers;
    exports.getTeamPropertiesMapForProduct = getTeamPropertiesMapForProduct;
    exports.getTeamStatus = getTeamStatus;
    exports.getTeamTemplate = getTeamTemplate;
    exports.getTeamTypesAvailableInProduct = getTeamTypesAvailableInProduct;
    exports.getTeamsAvailableInProduct = getTeamsAvailableInProduct;
    exports.getTeamsForProduct = getTeamsForProduct;
    exports.getUniqueGroupTitle = getUniqueGroupTitle;
    exports.getUserCreatableTeams = getUserCreatableTeams;
    exports.groupUsersByOrgRelationship = groupUsersByOrgRelationship;
    exports.handleNoUsers = handleNoUsers;
    exports.hasAllPrivileges = hasAllPrivileges;
    exports.processAutoAddUsers = processAutoAddUsers;
    exports.processEmailUsers = processEmailUsers;
    exports.processInviteUsers = processInviteUsers;
    exports.removeTeam = removeTeam;
    exports.removeTeamFromItems = removeTeamFromItems;
    exports.removeUsersFromTeam = removeUsersFromTeam;
    exports.removeUsersFromTeams = removeUsersFromTeams;
    exports.searchTeamContent = searchTeamContent;
    exports.searchTeamMembers = searchTeamMembers;
    exports.teamsToAddUsersTo = teamsToAddUsersTo;
    exports.updateTeam = updateTeam;
    exports.updateUserMembership = updateUserMembership;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=teams.umd.js.map
